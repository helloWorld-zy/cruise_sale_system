# Sprint 3: Booking Flow + User System Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build user system and booking flow from authentication to order creation across backend/admin/web/miniapp.

**Architecture:** Extend backend with user and booking domains, booking service for cabin holds, and public APIs. Frontends implement login and booking steps using Composition API and shared types.

**Tech Stack:** Go 1.26, Gin, GORM, PostgreSQL 17, Redis 7.4, Nuxt 4, Vue 3, Pinia, Vitest, Playwright, uni-app.

---

## Part A: Backend Users + Booking (Tasks 1-6)

### Task 1: User + Passenger Domain Models

**Files:**
- Create: `backend/internal/domain/user.go`
- Create: `backend/internal/domain/passenger.go`
- Test: `backend/internal/domain/user_test.go`

**Step 1: Write the failing test**

Create `backend/internal/domain/user_test.go`:

```go
package domain

import "testing"

func TestUserModelFields(t *testing.T) {
    u := User{Phone: "13800000000"}
    if u.Phone == "" {
        t.Fatal("expected phone")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/domain -run TestUserModelFields -v`
Expected: FAIL with "undefined: User"

**Step 3: Write minimal implementation**

Create `backend/internal/domain/user.go`:

```go
package domain

import "time"

type User struct {
    ID int64 `gorm:"primaryKey"`
    Phone string `gorm:"size:20;uniqueIndex"`
    WxOpenID string `gorm:"size:80;uniqueIndex"`
    Nickname string `gorm:"size:50"`
    AvatarURL string `gorm:"size:500"`
    Status int16 `gorm:"default:1"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/passenger.go`:

```go
package domain

import "time"

type Passenger struct {
    ID int64 `gorm:"primaryKey"`
    UserID int64 `gorm:"index"`
    Name string `gorm:"size:50"`
    IDType string `gorm:"size:20"`
    IDNumber string `gorm:"size:50"`
    Birthday time.Time
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/domain -run TestUserModelFields -v`
Expected: PASS

**Step 5: Refactor (normalize naming)**

Update `backend/internal/domain/passenger.go` to align field naming:

```go
type Passenger struct {
    ID int64 `gorm:"primaryKey"`
    UserID int64 `gorm:"index"`
    Name string `gorm:"size:50"`
    IDType string `gorm:"size:20"`
    IDNumber string `gorm:"size:50;column:id_number"`
    Birthday time.Time
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Run: `cd backend && go test ./internal/domain -run TestUserModelFields -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/domain/user.go backend/internal/domain/passenger.go backend/internal/domain/user_test.go
git commit -m "feat: add user and passenger domain models"
```

---

### Task 2: User + Booking Migrations

**Files:**
- Create: `backend/migrations/000003_user_booking.up.sql`
- Create: `backend/migrations/000003_user_booking.down.sql`
- Test: `backend/migrations/migrations_sprint3_test.go`

**Step 1: Write the failing test**

Create `backend/migrations/migrations_sprint3_test.go`:

```go
package migrations

import (
    "os"
    "testing"
)

func TestSprint3MigrationFilesExist(t *testing.T) {
    files := []string{
        "000003_user_booking.up.sql",
        "000003_user_booking.down.sql",
    }
    for _, f := range files {
        if _, err := os.Stat("migrations/" + f); err != nil {
            t.Fatalf("expected %s", f)
        }
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./migrations -run TestSprint3MigrationFilesExist -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/migrations/000003_user_booking.up.sql`:

```sql
CREATE TABLE IF NOT EXISTS users (
  id BIGSERIAL PRIMARY KEY,
  phone VARCHAR(20) UNIQUE,
  wx_open_id VARCHAR(80) UNIQUE,
  nickname VARCHAR(50),
  avatar_url VARCHAR(500),
  status SMALLINT DEFAULT 1,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS passengers (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id),
  name VARCHAR(50) NOT NULL,
  id_type VARCHAR(20) NOT NULL,
  id_number VARCHAR(50) NOT NULL,
  birthday TIMESTAMP,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS bookings (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT NOT NULL REFERENCES users(id),
  voyage_id BIGINT NOT NULL,
  cabin_sku_id BIGINT NOT NULL,
  status VARCHAR(20) NOT NULL,
  total_cents BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS booking_passengers (
  id BIGSERIAL PRIMARY KEY,
  booking_id BIGINT NOT NULL REFERENCES bookings(id),
  passenger_id BIGINT NOT NULL REFERENCES passengers(id)
);

CREATE TABLE IF NOT EXISTS cabin_holds (
  id BIGSERIAL PRIMARY KEY,
  cabin_sku_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  qty INT NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

Create `backend/migrations/000003_user_booking.down.sql`:

```sql
DROP TABLE IF EXISTS cabin_holds;
DROP TABLE IF EXISTS booking_passengers;
DROP TABLE IF EXISTS bookings;
DROP TABLE IF EXISTS passengers;
DROP TABLE IF EXISTS users;
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./migrations -run TestSprint3MigrationFilesExist -v`
Expected: PASS

**Step 5: Refactor (indexes)**

Update `backend/migrations/000003_user_booking.up.sql`:

```sql
CREATE INDEX IF NOT EXISTS idx_bookings_user_id ON bookings(user_id);
CREATE INDEX IF NOT EXISTS idx_cabin_holds_sku ON cabin_holds(cabin_sku_id);
```

Run: `cd backend && go test ./migrations -run TestSprint3MigrationFilesExist -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/migrations/000003_user_booking.up.sql backend/migrations/000003_user_booking.down.sql backend/migrations/migrations_sprint3_test.go
git commit -m "feat: add user and booking schema"
```

---

### Task 3: User Auth Service (SMS + WeChat)

**Files:**
- Create: `backend/internal/service/user_auth_service.go`
- Create: `backend/internal/service/user_auth_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/user_auth_service_test.go`:

```go
package service

import "testing"

type fakeCodeStore struct{ ok bool }
func (f *fakeCodeStore) Save(phone, code string) error { return nil }
func (f *fakeCodeStore) Verify(phone, code string) bool { return f.ok }

func TestUserAuthVerifySMS(t *testing.T) {
    svc := NewUserAuthService(&fakeCodeStore{ok: true})
    if !svc.VerifySMS("13800000000", "1234") {
        t.Fatal("expected sms verify")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestUserAuthVerifySMS -v`
Expected: FAIL with "undefined: NewUserAuthService"

**Step 3: Write minimal implementation**

Create `backend/internal/service/user_auth_service.go`:

```go
package service

type CodeStore interface {
    Save(phone, code string) error
    Verify(phone, code string) bool
}

type UserAuthService struct { store CodeStore }

func NewUserAuthService(store CodeStore) *UserAuthService { return &UserAuthService{store: store} }

func (s *UserAuthService) SendSMS(phone, code string) error {
    return s.store.Save(phone, code)
}

func (s *UserAuthService) VerifySMS(phone, code string) bool {
    return s.store.Verify(phone, code)
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestUserAuthVerifySMS -v`
Expected: PASS

**Step 5: Refactor (wechat login stub)**

Update `backend/internal/service/user_auth_service.go`:

```go
func (s *UserAuthService) WechatLogin(openID string) string {
    return openID
}
```

Run: `cd backend && go test ./internal/service -run TestUserAuthVerifySMS -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/service/user_auth_service.go backend/internal/service/user_auth_service_test.go
git commit -m "feat: add user auth service"
```

---

### Task 4: Booking Repository

**Files:**
- Create: `backend/internal/repository/booking_repo.go`
- Create: `backend/internal/repository/booking_repo_test.go`

**Step 1: Write the failing test**

Create `backend/internal/repository/booking_repo_test.go`:

```go
package repository

import (
    "testing"

    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func TestBookingRepoCreate(t *testing.T) {
    db, _ := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    _ = db.AutoMigrate(&domain.Booking{})
    repo := NewBookingRepository(db)
    err := repo.Create(&domain.Booking{UserID: 1, VoyageID: 2, CabinSKUID: 3, Status: "created", TotalCents: 100})
    if err != nil {
        t.Fatal(err)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/repository -run TestBookingRepoCreate -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/domain/booking.go`:

```go
package domain

import "time"

type Booking struct {
    ID int64 `gorm:"primaryKey"`
    UserID int64 `gorm:"index"`
    VoyageID int64
    CabinSKUID int64
    Status string `gorm:"size:20"`
    TotalCents int64
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/repository/booking_repo.go`:

```go
package repository

import (
    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/gorm"
)

type BookingRepository struct { db *gorm.DB }

func NewBookingRepository(db *gorm.DB) *BookingRepository { return &BookingRepository{db: db} }

func (r *BookingRepository) Create(b *domain.Booking) error { return r.db.Create(b).Error }
func (r *BookingRepository) ListByUser(userID int64) ([]domain.Booking, error) {
    var out []domain.Booking
    return out, r.db.Where("user_id = ?", userID).Order("id desc").Find(&out).Error
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/repository -run TestBookingRepoCreate -v`
Expected: PASS

**Step 5: Refactor (add booking passengers model)**

Create `backend/internal/domain/booking_passenger.go`:

```go
package domain

type BookingPassenger struct {
    ID int64 `gorm:"primaryKey"`
    BookingID int64 `gorm:"index"`
    PassengerID int64 `gorm:"index"`
}
```

Run: `cd backend && go test ./internal/repository -run TestBookingRepoCreate -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/domain/booking.go backend/internal/domain/booking_passenger.go backend/internal/repository/booking_repo.go backend/internal/repository/booking_repo_test.go
git commit -m "feat: add booking repository"
```

---

### Task 5: Booking Service (Hold + Create)

**Files:**
- Create: `backend/internal/service/booking_service.go`
- Create: `backend/internal/service/booking_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/booking_service_test.go`:

```go
package service

import "testing"

type fakeBookingRepo struct{ created bool }
func (f *fakeBookingRepo) Create(_ interface{}) error { f.created = true; return nil }

type fakePriceService struct{}
func (f fakePriceService) FindPrice(_ int64, _ interface{}, _ int) (int64, bool) { return 10000, true }

type fakeHoldService struct{ ok bool }
func (f *fakeHoldService) Hold(_ int64, _ int64, _ int) bool { f.ok = true; return true }

func TestBookingServiceCreate(t *testing.T) {
    svc := NewBookingService(&fakeBookingRepo{}, fakePriceService{}, &fakeHoldService{})
    if err := svc.Create(1, 2, 3, 2); err != nil {
        t.Fatal(err)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestBookingServiceCreate -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/service/booking_service.go`:

```go
package service

import "time"

type BookingRepo interface { Create(b interface{}) error }
type PriceService interface { FindPrice(skuID int64, date time.Time, occupancy int) (int64, bool) }
type HoldService interface { Hold(skuID int64, userID int64, qty int) bool }

type BookingService struct {
    repo BookingRepo
    price PriceService
    hold HoldService
}

func NewBookingService(repo BookingRepo, price PriceService, hold HoldService) *BookingService {
    return &BookingService{repo: repo, price: price, hold: hold}
}

func (s *BookingService) Create(userID, voyageID, skuID int64, guests int) error {
    if !s.hold.Hold(skuID, userID, 1) { return nil }
    _, _ = s.price.FindPrice(skuID, time.Now(), guests)
    return s.repo.Create(map[string]interface{}{"user_id": userID, "voyage_id": voyageID, "cabin_sku_id": skuID, "status": "created"})
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestBookingServiceCreate -v`
Expected: PASS

**Step 5: Refactor (typed booking)**

Update `backend/internal/service/booking_service.go` to use `domain.Booking`:

```go
import "github.com/cruisebooking/backend/internal/domain"

type BookingRepo interface { Create(b *domain.Booking) error }

func (s *BookingService) Create(userID, voyageID, skuID int64, guests int) error {
    if !s.hold.Hold(skuID, userID, 1) { return nil }
    price, _ := s.price.FindPrice(skuID, time.Now(), guests)
    return s.repo.Create(&domain.Booking{UserID: userID, VoyageID: voyageID, CabinSKUID: skuID, Status: "created", TotalCents: price})
}
```

Run: `cd backend && go test ./internal/service -run TestBookingServiceCreate -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/service/booking_service.go backend/internal/service/booking_service_test.go
git commit -m "feat: add booking service"
```

---

### Task 6: Booking + User Handlers

**Files:**
- Create: `backend/internal/handler/user_handler.go`
- Create: `backend/internal/handler/booking_handler.go`
- Modify: `backend/internal/router/router.go`
- Test: `backend/internal/handler/booking_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/booking_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestCreateBooking(t *testing.T) {
    r := gin.New()
    h := NewBookingHandler(nil)
    r.POST("/api/bookings", h.Create)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("POST", "/api/bookings", nil))
    if w.Code != http.StatusOK {
        t.Fatalf("expected 200, got %d", w.Code)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestCreateBooking -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/handler/booking_handler.go`:

```go
package handler

import (
    "github.com/cruisebooking/backend/internal/pkg/response"
    "github.com/gin-gonic/gin"
)

type BookingHandler struct {}
func NewBookingHandler(_ interface{}) *BookingHandler { return &BookingHandler{} }

func (h *BookingHandler) Create(c *gin.Context) {
    response.Success(c, gin.H{"id": 1})
}
```

Create `backend/internal/handler/user_handler.go` with login and profile stubs.

Modify `backend/internal/router/router.go` to register `/api/bookings` and `/api/users` routes.

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestCreateBooking -v`
Expected: PASS

**Step 5: Refactor (wire services)**

Update `backend/internal/handler/booking_handler.go` to accept service interface:

```go
type BookingService interface { Create(userID, voyageID, skuID int64, guests int) error }

type BookingHandler struct { svc BookingService }
func NewBookingHandler(svc BookingService) *BookingHandler { return &BookingHandler{svc: svc} }
```

Run: `cd backend && go test ./internal/handler -run TestCreateBooking -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/handler/booking_handler.go backend/internal/handler/booking_handler_test.go backend/internal/handler/user_handler.go backend/internal/router/router.go
git commit -m "feat: add booking and user handlers"
```

---

## Part B: Admin (Task 7)

> Follow @vue-best-practices and @vue-testing-best-practices. Use `<script setup lang="ts">`.

### Task 7: Admin Booking List

**Files:**
- Create: `frontend/admin/pages/bookings/index.vue`
- Create: `frontend/admin/pages/bookings/[id].vue`
- Test: `frontend/admin/tests/unit/bookings.list.spec.ts`

**Step 1: Write the failing test**

Create `frontend/admin/tests/unit/bookings.list.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Page from '../../pages/bookings/index.vue'

describe('Admin Bookings', () => {
  it('renders bookings title', () => {
    const wrapper = mount(Page)
    expect(wrapper.text()).toContain('Bookings')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/admin && pnpm vitest run tests/unit/bookings.list.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/admin/pages/bookings/index.vue`:

```vue
<script setup lang="ts">
const items = [{ id: 1, status: 'created', total: 19900 }]
</script>

<template>
  <div class="page">
    <h1>Bookings</h1>
    <div v-for="b in items" :key="b.id">{{ b.id }} - {{ b.status }} - {{ b.total }}</div>
  </div>
</template>
```

Create `frontend/admin/pages/bookings/[id].vue` with a simple detail view.

**Step 4: Run test to verify it passes**

Run: `cd frontend/admin && pnpm vitest run tests/unit/bookings.list.spec.ts`
Expected: PASS

**Step 5: Refactor (extract row)**

Create `frontend/admin/components/BookingRow.vue` and update list page to use it.

**Step 6: Commit**

```bash
git add frontend/admin/pages/bookings/index.vue frontend/admin/pages/bookings/[id].vue frontend/admin/components/BookingRow.vue frontend/admin/tests/unit/bookings.list.spec.ts
git commit -m "feat: add admin bookings pages"
```

---

## Part C: Web Frontend (Task 8)

> Follow @vue-best-practices and @vue-testing-best-practices. Use `<script setup lang="ts">`.

### Task 8: Web Login + Booking Flow

**Files:**
- Create: `frontend/web/pages/account/login.vue`
- Create: `frontend/web/pages/booking/index.vue`
- Create: `frontend/web/pages/booking/confirm.vue`
- Test: `frontend/web/tests/unit/login.page.spec.ts`

**Step 1: Write the failing test**

Create `frontend/web/tests/unit/login.page.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import LoginPage from '../../pages/account/login.vue'

describe('Login Page', () => {
  it('renders phone input', () => {
    const wrapper = mount(LoginPage)
    expect(wrapper.find('input').exists()).toBe(true)
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/web && pnpm vitest run tests/unit/login.page.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/web/pages/account/login.vue`:

```vue
<script setup lang="ts">
const phone = ref('')
</script>

<template>
  <div class="page">
    <h1>Login</h1>
    <input v-model="phone" placeholder="Phone" />
  </div>
</template>
```

Create `frontend/web/pages/booking/index.vue` and `frontend/web/pages/booking/confirm.vue` with step scaffolds.

**Step 4: Run test to verify it passes**

Run: `cd frontend/web && pnpm vitest run tests/unit/login.page.spec.ts`
Expected: PASS

**Step 5: Refactor (extract form)**

Create `frontend/web/components/LoginForm.vue` and update login page.

**Step 6: Commit**

```bash
git add frontend/web/pages/account/login.vue frontend/web/pages/booking/index.vue frontend/web/pages/booking/confirm.vue frontend/web/components/LoginForm.vue frontend/web/tests/unit/login.page.spec.ts
git commit -m "feat: add web login and booking flow pages"
```

---

## Part D: Miniapp (Task 9)

### Task 9: Miniapp Login + Booking

**Files:**
- Create: `frontend/miniapp/pages/login/login.vue`
- Create: `frontend/miniapp/pages/booking/create.vue`
- Test: `frontend/miniapp/tests/login.spec.ts`

**Step 1: Write the failing test**

Create `frontend/miniapp/tests/login.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/vue'
import Login from '../pages/login/login.vue'

describe('Miniapp Login', () => {
  it('shows login title', () => {
    const { getByText } = render(Login)
    expect(getByText('Login')).toBeTruthy()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/miniapp && pnpm vitest run tests/login.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/miniapp/pages/login/login.vue`:

```vue
<template>
  <view class="page">
    <text>Login</text>
  </view>
</template>
```

Create `frontend/miniapp/pages/booking/create.vue` with a minimal booking form.

**Step 4: Run test to verify it passes**

Run: `cd frontend/miniapp && pnpm vitest run tests/login.spec.ts`
Expected: PASS

**Step 5: Refactor (shared button)**

Create `frontend/miniapp/components/PrimaryButton.vue` and use it on login page.

**Step 6: Commit**

```bash
git add frontend/miniapp/pages/login/login.vue frontend/miniapp/pages/booking/create.vue frontend/miniapp/components/PrimaryButton.vue frontend/miniapp/tests/login.spec.ts
git commit -m "feat: add miniapp login and booking pages"
```

---

## Part E: CI (Task 10)

### Task 10: CI for Booking Flow

**Files:**
- Modify: `.github/workflows/ci.yml`

**Step 1: Write the failing test**

Add a CI job reference for web/miniapp tests (initially missing).

**Step 2: Run test to verify it fails**

Run: `act -j test-web` and `act -j test-miniapp` and expect missing job failure.

**Step 3: Write minimal implementation**

Update `.github/workflows/ci.yml`:

```yaml
  test-web:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with: { version: 9 }
      - run: cd frontend/web && pnpm install && pnpm vitest run

  test-miniapp:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with: { version: 9 }
      - run: cd frontend/miniapp && pnpm install && pnpm vitest run
```

**Step 4: Run test to verify it passes**

Run: `act -j test-web` and `act -j test-miniapp`
Expected: PASS

**Step 5: Refactor (reuse setup)**

Extract a shared pnpm setup step using a composite action.

**Step 6: Commit**

```bash
git add .github/workflows/ci.yml
git commit -m "ci: add web and miniapp tests for sprint3"
```

---

## Final Verification

Run:

```bash
cd backend && go test ./... -coverprofile=coverage.out -covermode=atomic
cd frontend/admin && pnpm vitest run
cd frontend/web && pnpm vitest run
cd frontend/miniapp && pnpm vitest run
```

Expected: All tests pass and coverage remains at 100%.
