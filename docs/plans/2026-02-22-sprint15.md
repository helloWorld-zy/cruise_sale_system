# Sprint 15: 安全审计 + 渗透测试 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 完成安全基线检查、OWASP保护与渗透测试修复基础能力。

**Architecture:** 后端增加安全头、中间件校验与权限测试；前端提供安全提示与隐私设置；CI加入安全扫描。TDD驱动。

**Tech Stack:** Go 1.26, Gin, GORM, Nuxt 4 (admin/web), Vue 3, Vitest, Playwright, uni-app, gosec.

---

## Part A: Backend (Tasks 1-4)

### Task 1: 安全头中间件

**Files:**
- Create: `backend/internal/middleware/security_headers.go`
- Test: `backend/internal/middleware/security_headers_test.go`

**Step 1: Write the failing test**

Create `backend/internal/middleware/security_headers_test.go`:

```go
package middleware

import (
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestSecurityHeaders(t *testing.T) {
    r := gin.New()
    r.Use(SecurityHeaders())
    r.GET("/ping", func(c *gin.Context) { c.Status(200) })
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("GET", "/ping", nil))
    if w.Header().Get("X-Frame-Options") == "" {
        t.Fatal("expected security headers")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/middleware -run TestSecurityHeaders -v`
Expected: FAIL with "undefined: SecurityHeaders"

**Step 3: Write minimal implementation**

Create `backend/internal/middleware/security_headers.go`:

```go
package middleware

import "github.com/gin-gonic/gin"

func SecurityHeaders() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("Referrer-Policy", "no-referrer")
        c.Next()
    }
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/middleware -run TestSecurityHeaders -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/middleware/security_headers.go backend/internal/middleware/security_headers_test.go
git commit -m "feat: add security headers middleware"
```

---

### Task 2: 输入校验辅助函数

**Files:**
- Create: `backend/internal/service/validation.go`
- Test: `backend/internal/service/validation_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/validation_test.go`:

```go
package service

import "testing"

func TestIsSafeText(t *testing.T) {
    if !IsSafeText("hello") { t.Fatal("expected safe text") }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestIsSafeText -v`
Expected: FAIL with "undefined: IsSafeText"

**Step 3: Write minimal implementation**

Create `backend/internal/service/validation.go`:

```go
package service

import "strings"

func IsSafeText(v string) bool {
    return !strings.ContainsAny(v, "<>;")
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestIsSafeText -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/service/validation.go backend/internal/service/validation_test.go
git commit -m "feat: add input validation helper"
```

---

### Task 3: 权限穿透测试用例

**Files:**
- Create: `backend/internal/middleware/permission_test.go`

**Step 1: Write the failing test**

Create `backend/internal/middleware/permission_test.go`:

```go
package middleware

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestForbiddenWithoutRole(t *testing.T) {
    r := gin.New()
    r.Use(RBAC("../rbac/model.conf", "../rbac/policy.csv"))
    r.GET("/admin/test", func(c *gin.Context) { c.Status(200) })
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("GET", "/admin/test", nil))
    if w.Code != http.StatusForbidden {
        t.Fatalf("expected 403, got %d", w.Code)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/middleware -run TestForbiddenWithoutRole -v`
Expected: FAIL if RBAC not enforced

**Step 3: Write minimal implementation**

Ensure RBAC middleware is used for admin routes in router setup.

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/middleware -run TestForbiddenWithoutRole -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/middleware/permission_test.go
git commit -m "test: add permission bypass regression test"
```

---

### Task 4: 安全事件 API

**Files:**
- Create: `backend/internal/handler/security_handler.go`
- Test: `backend/internal/handler/security_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/security_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestSecurityEventsAPI(t *testing.T) {
    r := gin.New()
    h := NewSecurityHandler()
    r.GET("/security/events", h.List)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("GET", "/security/events", nil))
    if w.Code != http.StatusOK { t.Fatalf("expected 200, got %d", w.Code) }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestSecurityEventsAPI -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/handler/security_handler.go`:

```go
package handler

import "github.com/gin-gonic/gin"

type SecurityHandler struct{}

func NewSecurityHandler() *SecurityHandler { return &SecurityHandler{} }

func (h *SecurityHandler) List(c *gin.Context) { c.JSON(200, gin.H{"events": []string{}}) }
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestSecurityEventsAPI -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/handler/security_handler.go backend/internal/handler/security_handler_test.go
git commit -m "feat: add security events handler"
```

---

## Part B: Admin (Task 5)

> Follow @vue-best-practices and @vue-testing-best-practices.

### Task 5: 安全报告页面

**Files:**
- Create: `frontend/admin/pages/security/report.vue`
- Test: `frontend/admin/tests/unit/security/report.spec.ts`

**Step 1: Write the failing test**

Create `frontend/admin/tests/unit/security/report.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import ReportPage from '@/pages/security/report.vue'

describe('ReportPage', () => {
  it('renders heading', () => {
    const wrapper = mount(ReportPage)
    expect(wrapper.text()).toContain('Security Report')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/admin && pnpm vitest run tests/unit/security/report.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/admin/pages/security/report.vue`:

```vue
<script setup lang="ts">
const items = ref(['XSS check', 'SQL injection check'])
</script>

<template>
  <section>
    <h1>Security Report</h1>
    <ul>
      <li v-for="i in items" :key="i">{{ i }}</li>
    </ul>
  </section>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/admin && pnpm vitest run tests/unit/security/report.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/admin/pages/security/report.vue frontend/admin/tests/unit/security/report.spec.ts
git commit -m "feat: add security report page"
```

---

## Part C: Web (Task 6)

### Task 6: 安全提示组件

**Files:**
- Create: `frontend/web/components/SecurityNotice.vue`
- Test: `frontend/web/tests/unit/security-notice.spec.ts`

**Step 1: Write the failing test**

Create `frontend/web/tests/unit/security-notice.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import SecurityNotice from '@/components/SecurityNotice.vue'

describe('SecurityNotice', () => {
  it('renders text', () => {
    const wrapper = mount(SecurityNotice, { props: { text: 'Safe' } })
    expect(wrapper.text()).toContain('Safe')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/web && pnpm vitest run tests/unit/security-notice.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/web/components/SecurityNotice.vue`:

```vue
<script setup lang="ts">
defineProps<{ text: string }>()
</script>

<template>
  <div>{{ text }}</div>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/web && pnpm vitest run tests/unit/security-notice.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/web/components/SecurityNotice.vue frontend/web/tests/unit/security-notice.spec.ts
git commit -m "feat: add security notice component"
```

---

## Part D: Miniapp (Task 7)

### Task 7: 小程序隐私设置

**Files:**
- Create: `frontend/miniapp/pages/settings/privacy.vue`
- Test: `frontend/miniapp/tests/privacy.spec.ts`

**Step 1: Write the failing test**

Create `frontend/miniapp/tests/privacy.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import PrivacyPage from '@/pages/settings/privacy.vue'

describe('PrivacyPage', () => {
  it('exists', () => {
    expect(PrivacyPage).toBeTruthy()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/miniapp && pnpm vitest run tests/privacy.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/miniapp/pages/settings/privacy.vue`:

```vue
<script setup lang="ts">
const marketing = ref(false)
</script>

<template>
  <view>
    <text>Privacy</text>
    <switch v-model="marketing"></switch>
  </view>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/miniapp && pnpm vitest run tests/privacy.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/miniapp/pages/settings/privacy.vue frontend/miniapp/tests/privacy.spec.ts
git commit -m "feat: add miniapp privacy settings"
```

---

## Part E: CI (Task 8)

### Task 8: 安全扫描工作流

**Files:**
- Modify: `.github/workflows/backend.yml`

**Step 1: Write the failing test**

Create `scripts/verify_security_ci_test.go`:

```go
package scripts

import (
    "os"
    "testing"
)

func TestSecurityWorkflowExists(t *testing.T) {
    if _, err := os.Stat(".github/workflows/backend.yml"); err != nil {
        t.Fatal("expected backend workflow")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./scripts -run TestSecurityWorkflowExists -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Add a CI step to run `gosec ./...` and `pnpm audit --production` in frontend workflows.

**Step 4: Run test to verify it passes**

Run: `go test ./scripts -run TestSecurityWorkflowExists -v`
Expected: PASS

**Step 5: Commit**

```bash
git add .github/workflows/backend.yml scripts/verify_security_ci_test.go
git commit -m "chore: add security scanning to CI"
```

---

## Final Verification

Run:

```bash
cd backend && go test ./... -coverprofile=coverage.out -covermode=atomic -v
cd backend && gosec ./...
cd frontend/admin && pnpm vitest run --coverage && pnpm playwright test
cd frontend/web && pnpm vitest run --coverage && pnpm playwright test
cd frontend/miniapp && pnpm vitest run --coverage
```

Expected: All tests pass and coverage is 100%.
