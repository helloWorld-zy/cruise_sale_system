# Sprint 1 全量TDD计划（整合版）

> 说明：本文件整合 `2026-02-19-sprint1-*` 与基础设施计划，采用 **TDD（RED/GREEN/REFACTOR）**，中文叙述 + 英文代码/测试。所有 Vue 代码使用 `<script setup lang="ts">`。

## 目标与范围

**目标：** 完成 Sprint 1 基础设施 + 邮轮介绍模块的全链路落地：
- Monorepo 脚手架与 Docker 依赖服务
- 后端基础能力（配置、日志、DB、Auth/JWT/RBAC、Swagger、迁移）
- 邮轮介绍模块（公司、邮轮、舱房类型、设施分类、设施）
- 共享类型包
- 管理后台 / Web 前台 / 小程序基础页面
- CI（含测试与覆盖率）

**技术栈：** Go + Gin + GORM + PostgreSQL + Redis + MinIO + Casbin + Swagger；Nuxt 4（Admin/Web）；uni-app（Miniapp）。

---

## 全局约定

- **TDD三步：** 先写失败测试（RED）→ 最小实现（GREEN）→ 必要重构（REFACTOR）。
- **测试覆盖率：** 后端/前端/小程序目标 100%。
- **命名统一：** API 路径 `/api/v1`，后台使用 `/api/v1/admin`。
- **Vue 代码规范：** 必须 `<script setup lang="ts">`。

---

# Part A 基础设施与脚手架（Infra）

## Task A1 - Git 初始化与基础配置

**目标：** 建立仓库基础规范与忽略规则。

**Files：**
- Create: `.gitignore`
- Create: `.editorconfig`

### RED

无自动化测试，使用清单校验：

```bash
git status
```

### GREEN

创建 `.gitignore` 与 `.editorconfig`（内容来自原计划）。

### REFACTOR

无。

### 验证

```bash
git status
```

---

## Task A2 - Docker Compose 开发环境

**目标：** PostgreSQL/Redis/MinIO/Meilisearch/NATS 一键起服务。

**Files：**
- Create: `docker/docker-compose.yml`
- Create: `docker/init-scripts/init-db.sql`
- Create: `.env.example`

### RED

无测试，使用服务健康检查：

```bash
cd docker
docker compose up -d
docker compose ps
```

### GREEN

按原计划写入 compose 与初始化 SQL。完成后运行：

```bash
docker compose ps
```

### REFACTOR

无。

### 验证

```bash
docker exec cruise_postgres psql -U cruise -d cruise_booking -c "SELECT 1;"
docker exec cruise_redis redis-cli -a redis_dev_2026 ping
```

---

## Task A3 - Go 后端项目初始化

**目标：** Go 模块、依赖、Makefile、Air 热更新和基础配置。

**Files：**
- Create: `backend/go.mod`
- Create: `backend/cmd/server/main.go`
- Create: `backend/Makefile`
- Create: `backend/.air.toml`
- Create: `backend/config.yaml`

### RED

运行构建预期失败（缺少文件）：

```bash
cd backend
go build ./...
```

### GREEN

按原计划创建文件并补齐依赖，然后再次构建：

```bash
cd backend
go build ./...
```

### REFACTOR

无。

### 验证

```bash
cd backend
go build ./...
```

---

# Part B 后端基础能力（Infra/Shared）

## Task B1 - 配置加载（Viper）

**Files：**
- Create: `backend/internal/config/config.go`
- Create: `backend/internal/config/config_test.go`
- Modify: `backend/cmd/server/main.go`

### RED

`backend/internal/config/config_test.go`

```go
package config

import "testing"

func TestLoad_Defaults(t *testing.T) {
    t.Setenv("CRUISE_SERVER_PORT", ":9000")

    cfg := Load("../../")

    if cfg.Server.Port != ":9000" {
        t.Fatalf("expected port :9000, got %s", cfg.Server.Port)
    }
    if cfg.Database.Host == "" {
        t.Fatalf("expected database host to be set")
    }
}
```

运行测试（应失败）：

```bash
cd backend
go test ./internal/config -v
```

### GREEN

`backend/internal/config/config.go`

```go
package config

import (
    "fmt"
    "path/filepath"
    "strings"

    "github.com/spf13/viper"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Redis    RedisConfig
    MinIO    MinIOConfig
    Meilis   MeiliConfig
    NATS     NATSConfig
    JWT      JWTConfig
    Log      LogConfig
}

type ServerConfig struct {
    Port string
    Mode string
}

type DatabaseConfig struct {
    Host            string
    Port            int
    User            string
    Password        string
    DBName          string
    SSLMode         string
    MaxIdleConns    int
    MaxOpenConns    int
    ConnMaxLifetime int
}

type RedisConfig struct {
    Host     string
    Port     int
    Password string
    DB       int
}

type MinIOConfig struct {
    Endpoint  string
    AccessKey string
    SecretKey string
    Bucket    string
    UseSSL    bool
}

type MeiliConfig struct {
    Host   string
    APIKey string
}

type NATSConfig struct {
    URL string
}

type JWTConfig struct {
    Secret      string
    ExpireHours int
}

type LogConfig struct {
    Level      string
    Filename   string
    MaxSize    int
    MaxBackups int
    MaxAge     int
    Compress   bool
}

// Load reads config.yaml and overlays environment variables with CRUISE_ prefix.
func Load(root string) Config {
    v := viper.New()
    v.SetConfigName("config")
    v.SetConfigType("yaml")
    v.AddConfigPath(filepath.Join(root))
    v.AddConfigPath(".")

    v.SetEnvPrefix("CRUISE")
    v.AutomaticEnv()
    v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

    if err := v.ReadInConfig(); err != nil {
        panic(fmt.Errorf("read config: %w", err))
    }

    var cfg Config
    if err := v.Unmarshal(&cfg); err != nil {
        panic(fmt.Errorf("unmarshal config: %w", err))
    }

    return cfg
}
```

`backend/cmd/server/main.go`

```go
package main

import (
    "log"

    "github.com/cruisebooking/backend/internal/config"
)

func main() {
    cfg := config.Load(".")
    log.Printf("server starting on %s", cfg.Server.Port)
}
```

### REFACTOR

无。

### 验证

```bash
cd backend
go test ./internal/config -v
```

---

## Task B2 - Logger（Zap + Lumberjack）

**Files：**
- Create: `backend/internal/pkg/logger/logger.go`
- Create: `backend/internal/pkg/logger/logger_test.go`

### RED

`backend/internal/pkg/logger/logger_test.go`

```go
package logger

import "testing"

func TestNewLogger(t *testing.T) {
    l := New("debug", "logs/test.log")
    if l == nil {
        t.Fatal("expected logger to be non-nil")
    }
}
```

```bash
cd backend
go test ./internal/pkg/logger -v
```

### GREEN

`backend/internal/pkg/logger/logger.go`

```go
package logger

import (
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
    "gopkg.in/natefinch/lumberjack.v2"
)

func New(level string, filename string) *zap.Logger {
    lj := &lumberjack.Logger{
        Filename:   filename,
        MaxSize:    100,
        MaxBackups: 10,
        MaxAge:     30,
        Compress:   true,
    }

    encoderCfg := zap.NewProductionEncoderConfig()
    encoderCfg.TimeKey = "time"
    encoderCfg.EncodeTime = zapcore.ISO8601TimeEncoder

    atomicLevel := zap.NewAtomicLevel()
    if err := atomicLevel.UnmarshalText([]byte(level)); err != nil {
        atomicLevel.SetLevel(zapcore.InfoLevel)
    }

    core := zapcore.NewCore(
        zapcore.NewJSONEncoder(encoderCfg),
        zapcore.AddSync(lj),
        atomicLevel,
    )

    return zap.New(core, zap.AddCaller())
}
```

### REFACTOR

无。

### 验证

```bash
cd backend
go test ./internal/pkg/logger -v
```

---

## Task B3 - 数据库连接（GORM）

**Files：**
- Create: `backend/internal/pkg/database/database.go`
- Create: `backend/internal/pkg/database/database_test.go`

### RED

`backend/internal/pkg/database/database_test.go`

```go
package database

import "testing"

func TestDSN(t *testing.T) {
    dsn := BuildDSN(Config{
        Host:     "localhost",
        Port:     5432,
        User:     "user",
        Password: "pass",
        DBName:   "db",
        SSLMode:  "disable",
    })

    if dsn == "" {
        t.Fatal("expected DSN to be non-empty")
    }
}
```

```bash
cd backend
go test ./internal/pkg/database -v
```

### GREEN

`backend/internal/pkg/database/database.go`

```go
package database

import (
    "fmt"
    "time"

    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

type Config struct {
    Host            string
    Port            int
    User            string
    Password        string
    DBName          string
    SSLMode         string
    MaxIdleConns    int
    MaxOpenConns    int
    ConnMaxLifetime int
}

func BuildDSN(cfg Config) string {
    return fmt.Sprintf(
        "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
        cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName, cfg.SSLMode,
    )
}

func Connect(cfg Config) (*gorm.DB, error) {
    db, err := gorm.Open(postgres.Open(BuildDSN(cfg)), &gorm.Config{})
    if err != nil {
        return nil, err
    }

    sqlDB, err := db.DB()
    if err != nil {
        return nil, err
    }
    sqlDB.SetMaxIdleConns(cfg.MaxIdleConns)
    sqlDB.SetMaxOpenConns(cfg.MaxOpenConns)
    sqlDB.SetConnMaxLifetime(time.Duration(cfg.ConnMaxLifetime) * time.Second)

    return db, nil
}
```

### REFACTOR

无。

### 验证

```bash
cd backend
go test ./internal/pkg/database -v
```

---

# Part C 认证与权限（Auth / JWT / RBAC）

## Task C1 - Auth Models + JWT + RBAC

**Files：**
- Create: `backend/internal/domain/staff.go`
- Create: `backend/internal/domain/role.go`
- Create: `backend/internal/repository/staff_repo.go`
- Create: `backend/internal/service/auth_service.go`
- Create: `backend/internal/middleware/auth.go`
- Create: `backend/internal/middleware/rbac.go`
- Create: `backend/rbac/model.conf`
- Create: `backend/rbac/policy.csv`

### RED

`backend/internal/service/auth_service_test.go`

```go
package service

import "testing"

func TestAuthPasswordHashing(t *testing.T) {
    hash, err := HashPassword("secret")
    if err != nil {
        t.Fatalf("hash error: %v", err)
    }
    if !VerifyPassword(hash, "secret") {
        t.Fatal("expected password to verify")
    }
}

func TestAuthJWT(t *testing.T) {
    token, err := GenerateJWT(1, []string{"admin"}, "secret", 1)
    if err != nil {
        t.Fatalf("jwt error: %v", err)
    }
    if token == "" {
        t.Fatal("expected jwt token")
    }
}
```

运行（应失败）：

```bash
cd backend
go test ./internal/service -run TestAuth -v
```

### GREEN

`backend/internal/domain/staff.go`

```go
package domain

import "time"

type Staff struct {
    ID           int64     `gorm:"primaryKey"`
    Username     string    `gorm:"size:50;uniqueIndex"`
    PasswordHash string    `gorm:"size:255"`
    RealName     string    `gorm:"size:50"`
    Phone        string    `gorm:"size:20"`
    Email        string    `gorm:"size:100"`
    AvatarURL    string    `gorm:"size:500"`
    Status       int16     `gorm:"default:1"`
    LastLoginAt  *time.Time
    CreatedAt    time.Time
    UpdatedAt    time.Time
    DeletedAt    *time.Time `gorm:"index"`
}
```

`backend/internal/domain/role.go`

```go
package domain

import "time"

type Role struct {
    ID          int64     `gorm:"primaryKey"`
    Name        string    `gorm:"size:50;uniqueIndex"`
    DisplayName string    `gorm:"size:100"`
    Description string    `gorm:"type:text"`
    CreatedAt   time.Time
    UpdatedAt   time.Time
}
```

`backend/internal/service/auth_service.go`

```go
package service

import (
    "time"

    "github.com/golang-jwt/jwt/v5"
    "golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

func VerifyPassword(hash, password string) bool {
    return bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) == nil
}

func GenerateJWT(staffID int64, roles []string, secret string, expireHours int) (string, error) {
    claims := jwt.MapClaims{
        "sub":   staffID,
        "roles": roles,
        "exp":   time.Now().Add(time.Duration(expireHours) * time.Hour).Unix(),
    }
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(secret))
}
```

`backend/internal/middleware/auth.go`（最小 JWT 校验结构）

```go
package middleware

import (
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
)

type JWTConfig struct {
    Secret string
}

func JWT(cfg JWTConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        auth := c.GetHeader("Authorization")
        if auth == "" || !strings.HasPrefix(auth, "Bearer ") {
            c.AbortWithStatus(http.StatusUnauthorized)
            return
        }
        tokenStr := strings.TrimPrefix(auth, "Bearer ")
        token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
            return []byte(cfg.Secret), nil
        })
        if err != nil || !token.Valid {
            c.AbortWithStatus(http.StatusUnauthorized)
            return
        }
        c.Next()
    }
}
```

`backend/internal/middleware/rbac.go`（Casbin 基础）

```go
package middleware

import (
    "net/http"

    "github.com/casbin/casbin/v2"
    "github.com/gin-gonic/gin"
)

func RBAC(enforcer *casbin.Enforcer) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 最小实现：仅示意，实际需从 JWT/上下文获取角色
        sub := "admin"
        obj := c.Request.URL.Path
        act := c.Request.Method
        ok, _ := enforcer.Enforce(sub, obj, act)
        if !ok {
            c.AbortWithStatus(http.StatusForbidden)
            return
        }
        c.Next()
    }
}
```

### REFACTOR

- 将 JWT 校验与角色解析封装为独立函数（若测试覆盖更多场景）。

### 验证

```bash
cd backend
go test ./internal/service -run TestAuth -v
```

---

# Part D 邮轮介绍模块（Domain/Repo/Service/Handler）

## Task D1 - Domain Models

**Files：**
- Create: `backend/internal/domain/company.go`
- Create: `backend/internal/domain/cruise.go`
- Create: `backend/internal/domain/cabin_type.go`
- Create: `backend/internal/domain/facility_category.go`
- Create: `backend/internal/domain/facility.go`
- Create: `backend/internal/domain/image.go`

### RED

无测试（纯模型）。

### GREEN

使用原计划模型定义（详见原文件）。

### REFACTOR

无。

---

## Task D2 - Repository 接口与实现

**Files：**
- Create: `backend/internal/domain/repository.go`
- Create: `backend/internal/repository/company_repo.go`
- Create: `backend/internal/repository/cruise_repo.go`
- Create: `backend/internal/repository/cabin_type_repo.go`
- Create: `backend/internal/repository/facility_category_repo.go`
- Create: `backend/internal/repository/facility_repo.go`
- Create: `backend/internal/repository/company_repo_test.go`

### RED

`backend/internal/repository/company_repo_test.go`

```go
package repository

import (
    "context"
    "testing"

    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func TestCompanyRepository_List(t *testing.T) {
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    if err != nil {
        t.Fatalf("db error: %v", err)
    }
    if err := db.AutoMigrate(&domain.CruiseCompany{}); err != nil {
        t.Fatalf("migrate error: %v", err)
    }
    repo := NewCompanyRepository(db)
    _ = repo.Create(context.Background(), &domain.CruiseCompany{Name: "A"})

    items, total, err := repo.List(context.Background(), "A", 1, 10)
    if err != nil {
        t.Fatalf("list error: %v", err)
    }
    if total == 0 || len(items) == 0 {
        t.Fatal("expected items")
    }
}
```

```bash
cd backend
go test ./internal/repository -v
```

### GREEN

实现 `repository.go` 与各仓储结构，最小实现满足测试。

示例 `company_repo.go`：

```go
package repository

import (
    "context"

    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/gorm"
)

type CompanyRepository struct {
    db *gorm.DB
}

func NewCompanyRepository(db *gorm.DB) *CompanyRepository {
    return &CompanyRepository{db: db}
}

func (r *CompanyRepository) Create(ctx context.Context, company *domain.CruiseCompany) error {
    return r.db.WithContext(ctx).Create(company).Error
}

func (r *CompanyRepository) Update(ctx context.Context, company *domain.CruiseCompany) error {
    return r.db.WithContext(ctx).Save(company).Error
}

func (r *CompanyRepository) GetByID(ctx context.Context, id int64) (*domain.CruiseCompany, error) {
    var company domain.CruiseCompany
    if err := r.db.WithContext(ctx).First(&company, id).Error; err != nil {
        return nil, err
    }
    return &company, nil
}

func (r *CompanyRepository) List(ctx context.Context, keyword string, page, pageSize int) ([]domain.CruiseCompany, int64, error) {
    var items []domain.CruiseCompany
    var total int64
    q := r.db.WithContext(ctx).Model(&domain.CruiseCompany{})
    if keyword != "" {
        q = q.Where("name LIKE ?", "%"+keyword+"%")
    }
    if err := q.Count(&total).Error; err != nil {
        return nil, 0, err
    }
    if err := q.Offset((page-1)*pageSize).Limit(pageSize).Order("sort_order desc, id desc").Find(&items).Error; err != nil {
        return nil, 0, err
    }
    return items, total, nil
}

func (r *CompanyRepository) Delete(ctx context.Context, id int64) error {
    return r.db.WithContext(ctx).Delete(&domain.CruiseCompany{}, id).Error
}
```

### REFACTOR

- 为其他仓储补齐查询条件（status, cruiseID, categoryID）测试覆盖。

### 验证

```bash
cd backend
go test ./internal/repository -v
```

---

## Task D3 - Service 业务规则

**Files：**
- Create: `backend/internal/service/company_service.go`
- Create: `backend/internal/service/cruise_service.go`
- Create: `backend/internal/service/cabin_type_service.go`
- Create: `backend/internal/service/facility_category_service.go`
- Create: `backend/internal/service/facility_service.go`
- Create: `backend/internal/service/service_test.go`

### RED

`backend/internal/service/service_test.go`

```go
package service

import (
    "context"
    "errors"
    "testing"

    "github.com/cruisebooking/backend/internal/domain"
)

type mockCompanyRepo struct{}
func (m *mockCompanyRepo) GetByID(ctx context.Context, id int64) (*domain.CruiseCompany, error) {
    return nil, errors.New("not found")
}

type mockCruiseRepo struct{ created bool }
func (m *mockCruiseRepo) Create(ctx context.Context, cruise *domain.Cruise) error { m.created = true; return nil }

type mockCabinRepo struct{}
func (m *mockCabinRepo) ListByCruise(ctx context.Context, cruiseID int64, page, pageSize int) ([]domain.CabinType, int64, error) {
    return []domain.CabinType{{ID: 1}}, 1, nil
}

func TestCruiseService_CreateRequiresCompany(t *testing.T) {
    svc := NewCruiseService(&mockCruiseRepo{}, &mockCabinRepo{}, &mockCompanyRepo{})
    err := svc.Create(context.Background(), &domain.Cruise{CompanyID: 99})
    if err == nil {
        t.Fatal("expected error when company not found")
    }
}

func TestCruiseService_DeleteFailsWhenCabinsExist(t *testing.T) {
    svc := NewCruiseService(&mockCruiseRepo{}, &mockCabinRepo{}, &mockCompanyRepo{})
    err := svc.Delete(context.Background(), 1)
    if err == nil {
        t.Fatal("expected error when cabins exist")
    }
}
```

```bash
cd backend
go test ./internal/service -v
```

### GREEN

`backend/internal/service/cruise_service.go`

```go
package service

import (
    "context"
    "errors"

    "github.com/cruisebooking/backend/internal/domain"
)

var ErrCruiseHasCabins = errors.New("cruise has cabins")

type CruiseService struct {
    cruiseRepo  domain.CruiseRepository
    cabinRepo   domain.CabinTypeRepository
    companyRepo domain.CompanyRepository
}

func NewCruiseService(cruiseRepo domain.CruiseRepository, cabinRepo domain.CabinTypeRepository, companyRepo domain.CompanyRepository) *CruiseService {
    return &CruiseService{cruiseRepo: cruiseRepo, cabinRepo: cabinRepo, companyRepo: companyRepo}
}

func (s *CruiseService) Create(ctx context.Context, cruise *domain.Cruise) error {
    if _, err := s.companyRepo.GetByID(ctx, cruise.CompanyID); err != nil {
        return err
    }
    return s.cruiseRepo.Create(ctx, cruise)
}

func (s *CruiseService) Delete(ctx context.Context, id int64) error {
    cabins, total, err := s.cabinRepo.ListByCruise(ctx, id, 1, 1)
    if err != nil {
        return err
    }
    if total > 0 || len(cabins) > 0 {
        return ErrCruiseHasCabins
    }
    return s.cruiseRepo.Delete(ctx, id)
}
```

### REFACTOR

- 提取通用校验（如存在依赖删除失败）到 helper。

### 验证

```bash
cd backend
go test ./internal/service -v
```

---

## Task D4 - Handler + Router + Response

**Files：**
- Create: `backend/internal/handler/auth_handler.go`
- Create: `backend/internal/handler/company_handler.go`
- Create: `backend/internal/handler/cruise_handler.go`
- Create: `backend/internal/handler/cabin_type_handler.go`
- Create: `backend/internal/handler/facility_category_handler.go`
- Create: `backend/internal/handler/facility_handler.go`
- Create: `backend/internal/handler/upload_handler.go`
- Create: `backend/internal/router/router.go`
- Create: `backend/internal/pkg/response/response.go`
- Create: `backend/internal/pkg/errcode/errcode.go`

### RED

`backend/internal/handler/cruise_handler_test.go`

```go
package handler

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

type mockCruiseService struct{}

func (m *mockCruiseService) Create(c *gin.Context) {}

func TestCruiseHandler_Create(t *testing.T) {
    gin.SetMode(gin.TestMode)
    r := gin.New()
    r.POST("/api/v1/admin/cruises", func(c *gin.Context) {
        c.JSON(200, gin.H{"code": 0})
    })

    payload := map[string]any{"name": "Test Cruise"}
    body, _ := json.Marshal(payload)
    req := httptest.NewRequest(http.MethodPost, "/api/v1/admin/cruises", bytes.NewReader(body))
    req.Header.Set("Content-Type", "application/json")
    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)

    if w.Code != 200 {
        t.Fatalf("expected 200 got %d", w.Code)
    }
}
```

### GREEN

`backend/internal/pkg/response/response.go`

```go
package response

import "github.com/gin-gonic/gin"

type Response struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data"`
}

func Success(c *gin.Context, data interface{}) {
    c.JSON(200, Response{Code: 0, Message: "success", Data: data})
}

func Error(c *gin.Context, code int, message string) {
    c.JSON(200, Response{Code: code, Message: message, Data: nil})
}
```

`backend/internal/router/router.go`（最小）

```go
package router

import (
    "github.com/gin-gonic/gin"
)

func Setup() *gin.Engine {
    r := gin.New()
    api := r.Group("/api/v1")
    admin := api.Group("/admin")
    admin.POST("/cruises", func(c *gin.Context) {
        c.JSON(200, gin.H{"code": 0})
    })
    return r
}
```

### REFACTOR

- 将 handler/service 注入 router，替换匿名 handler。

### 验证

```bash
cd backend
go test ./internal/handler -v
```

---

# Part E 数据库迁移（Migrations）

## Task E1 - 初始迁移

**Files：**
- Create: `backend/migrations/000001_init_schema.up.sql`
- Create: `backend/migrations/000001_init_schema.down.sql`

### RED

执行迁移（应失败：文件不存在）：

```bash
cd backend
make migrate-up
```

### GREEN

编写迁移 SQL（含 cruise_companies, cruises, cabin_types, facilities, staffs, roles, staff_roles 等）。

### REFACTOR

- 为索引与外键补齐约束（如 Cruise → Company, CabinType → Cruise）。

### 验证

```bash
cd backend
make migrate-up
```

---

# Part F Swagger 文档

## Task F1 - Swagger 注解 + 生成

**Files：**
- Modify: `backend/cmd/server/main.go`
- Modify: `backend/internal/handler/*.go`

### RED

执行 `make swagger` 应失败（未添加注解）。

### GREEN

在 handler 中添加注解，例如：

```go
// @Summary Create cruise
// @Tags Cruise
// @Accept json
// @Produce json
// @Param body body CreateCruiseRequest true "Cruise data"
// @Success 200 {object} response.Response
// @Router /api/v1/admin/cruises [post]
```

运行：

```bash
cd backend
make swagger
```

### REFACTOR

- 将请求/响应结构抽取为 `dto`。

### 验证

```bash
cd backend
make swagger
```

---

# Part G 共享类型（Shared Types）

## Task G1 - 前端共享类型包

**Files：**
- Create: `frontend/shared/package.json`
- Create: `frontend/shared/types/index.ts`
- Create: `frontend/shared/types/api.ts`
- Create: `frontend/shared/constants/index.ts`

### RED

使用 TypeScript 直接导入验证（应失败，文件不存在）。

### GREEN

按原计划创建文件。

`frontend/shared/types/api.ts`

```ts
export interface ApiResponse<T = unknown> {
  code: number
  message: string
  data: T
}

export interface PaginatedData<T> {
  list: T[]
  pagination: Pagination
}

export interface Pagination {
  page: number
  page_size: number
  total: number
  total_pages: number
}

export type PaginatedResponse<T> = ApiResponse<PaginatedData<T>>

export interface ListQuery {
  page?: number
  page_size?: number
  keyword?: string
  sort_by?: string
  sort_order?: 'asc' | 'desc'
}
```

### REFACTOR

- 补齐 Cruise/Company/Cabin/Facility 类型，统一前后端字段。

### 验证

无。

---

# Part H 管理后台（Admin）

## Task H1 - 布局与全局样式

**Files：**
- Create: `frontend/admin/assets/css/main.css`
- Create: `frontend/admin/app/layouts/default.vue`
- Create: `frontend/admin/tests/unit/layouts/default.spec.ts`

### RED

`frontend/admin/tests/unit/layouts/default.spec.ts`

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import DefaultLayout from '../../../app/layouts/default.vue'

describe('Default layout', () => {
  it('renders a main content slot', () => {
    const wrapper = mount(DefaultLayout, {
      slots: { default: '<div data-test="content">Hello</div>' },
    })
    expect(wrapper.find('[data-test="content"]').exists()).toBe(true)
  })
})
```

```bash
cd frontend/admin
pnpm vitest tests/unit/layouts/default.spec.ts
```

### GREEN

`frontend/admin/app/layouts/default.vue`

```vue
<template>
  <div class="min-h-screen bg-[var(--admin-bg)]">
    <header class="h-14 bg-white border-b px-4 flex items-center">
      <div class="font-semibold">CruiseBooking Admin</div>
    </header>
    <div class="flex">
      <aside class="w-64 bg-white border-r min-h-[calc(100vh-56px)]">
        <nav class="p-3 space-y-1">
          <NuxtLink class="block px-3 py-2 rounded hover:bg-gray-50" to="/cruises">邮轮管理</NuxtLink>
          <NuxtLink class="block px-3 py-2 rounded hover:bg-gray-50" to="/cabin-types">舱房类型</NuxtLink>
          <NuxtLink class="block px-3 py-2 rounded hover:bg-gray-50" to="/facilities">设施管理</NuxtLink>
        </nav>
      </aside>
      <main class="flex-1 p-6">
        <slot />
      </main>
    </div>
  </div>
</template>

<script setup lang="ts">
</script>
```

### REFACTOR

- 提取侧边栏菜单为配置。

### 验证

```bash
cd frontend/admin
pnpm vitest tests/unit/layouts/default.spec.ts
```

---

## Task H2 - Auth Store + useApi

**Files：**
- Create: `frontend/admin/app/stores/auth.ts`
- Create: `frontend/admin/app/composables/useApi.ts`
- Create: `frontend/admin/tests/unit/composables/useApi.spec.ts`

### RED

`frontend/admin/tests/unit/composables/useApi.spec.ts`

```ts
import { describe, it, expect } from 'vitest'
import { useApi } from '../../../app/composables/useApi'

describe('useApi', () => {
  it('exposes baseUrl', () => {
    const api = useApi()
    expect(api.baseUrl).toContain('/api/v1')
  })
})
```

### GREEN

`frontend/admin/app/composables/useApi.ts`

```ts
import { useAuthStore } from '@/stores/auth'

export const useApi = () => {
  const config = useRuntimeConfig()
  const auth = useAuthStore()

  const baseUrl = config.public.apiBase

  const request = async <T>(path: string, options: any = {}) => {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    }
    if (auth.token) headers.Authorization = `Bearer ${auth.token}`

    return await $fetch<T>(`${baseUrl}${path}`, {
      ...options,
      headers: { ...headers, ...(options.headers || {}) },
    })
  }

  return { baseUrl, request }
}
```

`frontend/admin/app/stores/auth.ts`

```ts
import { defineStore } from 'pinia'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: '',
    profile: null as null | { id: number; username: string; roles: string[] },
  }),
  actions: {
    setToken(token: string) {
      this.token = token
    },
    setProfile(profile: { id: number; username: string; roles: string[] }) {
      this.profile = profile
    },
    logout() {
      this.token = ''
      this.profile = null
    },
  },
})
```

### REFACTOR

- 增加刷新 token 与过期处理。

### 验证

```bash
cd frontend/admin
pnpm vitest tests/unit/composables/useApi.spec.ts
```

---

## Task H3 - 登录页

**Files：**
- Create: `frontend/admin/app/pages/login.vue`
- Create: `frontend/admin/tests/unit/pages/login.spec.ts`

### RED

`frontend/admin/tests/unit/pages/login.spec.ts`

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import LoginPage from '../../../app/pages/login.vue'

describe('Login page', () => {
  it('renders login form', () => {
    const wrapper = mount(LoginPage)
    expect(wrapper.find('form').exists()).toBe(true)
  })
})
```

### GREEN

`frontend/admin/app/pages/login.vue`

```vue
<template>
  <div class="min-h-screen flex items-center justify-center bg-gray-50">
    <div class="w-full max-w-md bg-white border rounded-xl p-6">
      <h1 class="text-xl font-semibold mb-4">管理员登录</h1>
      <form class="space-y-3">
        <UInput v-model="username" placeholder="用户名" />
        <UInput v-model="password" type="password" placeholder="密码" />
        <UButton class="w-full" color="primary">登录</UButton>
      </form>
    </div>
  </div>
</template>

<script setup lang="ts">
const username = ref('')
const password = ref('')
</script>
```

### REFACTOR

- 添加表单校验与错误提示。

### 验证

```bash
cd frontend/admin
pnpm vitest tests/unit/pages/login.spec.ts
```

---

## Task H4 - 邮轮列表页

**Files：**
- Create: `frontend/admin/app/pages/cruises/index.vue`
- Create: `frontend/admin/tests/unit/pages/cruises-index.spec.ts`

### RED

`frontend/admin/tests/unit/pages/cruises-index.spec.ts`

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Page from '../../../app/pages/cruises/index.vue'

describe('Cruise list', () => {
  it('renders a table', () => {
    const wrapper = mount(Page)
    expect(wrapper.find('table').exists()).toBe(true)
  })
})
```

### GREEN

`frontend/admin/app/pages/cruises/index.vue`

```vue
<template>
  <div>
    <div class="flex items-center justify-between mb-4">
      <h1 class="text-xl font-semibold">邮轮管理</h1>
      <UButton to="/cruises/create" color="primary">新建邮轮</UButton>
    </div>
    <table class="w-full border">
      <thead>
        <tr class="bg-gray-50">
          <th class="text-left p-2">名称</th>
          <th class="text-left p-2">状态</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td class="p-2">示例邮轮</td>
          <td class="p-2">上架</td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

<script setup lang="ts">
</script>
```

### REFACTOR

- 接入 API 查询与分页。

### 验证

```bash
cd frontend/admin
pnpm vitest tests/unit/pages/cruises-index.spec.ts
```

---

# Part I Web 前台（Web）

## Task I1 - Web Layout

**Files：**
- Create: `frontend/web/app/layouts/default.vue`
- Create: `frontend/web/tests/unit/layouts/default.spec.ts`

### RED

`frontend/web/tests/unit/layouts/default.spec.ts`

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Layout from '../../../app/layouts/default.vue'

describe('Default layout', () => {
  it('renders a header', () => {
    const wrapper = mount(Layout, { slots: { default: '<div />' } })
    expect(wrapper.find('header').exists()).toBe(true)
  })
})
```

### GREEN

`frontend/web/app/layouts/default.vue`

```vue
<template>
  <div class="min-h-screen bg-white">
    <header class="border-b bg-white/90 backdrop-blur">
      <div class="max-w-6xl mx-auto px-4 h-16 flex items-center justify-between">
        <NuxtLink to="/" class="text-lg font-semibold">CruiseBooking</NuxtLink>
        <nav class="space-x-4 text-sm">
          <NuxtLink to="/cruises">邮轮</NuxtLink>
        </nav>
      </div>
    </header>
    <main class="max-w-6xl mx-auto px-4 py-8">
      <slot />
    </main>
    <footer class="border-t py-6 text-center text-sm text-gray-500">
      © 2026 CruiseBooking
    </footer>
  </div>
</template>

<script setup lang="ts">
</script>
```

### REFACTOR

- 提取导航为配置。

### 验证

```bash
cd frontend/web
pnpm vitest tests/unit/layouts/default.spec.ts
```

---

## Task I2 - Web useApi + Store

**Files：**
- Create: `frontend/web/app/composables/useApi.ts`
- Create: `frontend/web/app/stores/cruise.ts`
- Create: `frontend/web/tests/unit/composables/useApi.spec.ts`

### RED

`frontend/web/tests/unit/composables/useApi.spec.ts`

```ts
import { describe, it, expect } from 'vitest'
import { useApi } from '../../../app/composables/useApi'

describe('useApi', () => {
  it('exposes baseUrl', () => {
    const api = useApi()
    expect(api.baseUrl).toContain('/api/v1')
  })
})
```

### GREEN

`frontend/web/app/composables/useApi.ts`

```ts
export const useApi = () => {
  const config = useRuntimeConfig()
  const baseUrl = config.public.apiBase
  const request = async <T>(path: string, options: any = {}) => {
    return await $fetch<T>(`${baseUrl}${path}`, options)
  }
  return { baseUrl, request }
}
```

`frontend/web/app/stores/cruise.ts`

```ts
import { defineStore } from 'pinia'

export const useCruiseStore = defineStore('cruise', {
  state: () => ({ list: [] as any[], detail: null as any }),
  actions: {
    setList(list: any[]) { this.list = list },
    setDetail(detail: any) { this.detail = detail },
  },
})
```

### REFACTOR

- 引入共享类型 `@cruise/shared`。

### 验证

```bash
cd frontend/web
pnpm vitest tests/unit/composables/useApi.spec.ts
```

---

# Part J 小程序（Miniapp）

## Task J1 - Request Wrapper + Store

**Files：**
- Create: `frontend/miniapp/src/utils/request.ts`
- Create: `frontend/miniapp/src/stores/auth.ts`
- Create: `frontend/miniapp/tests/unit/request.spec.ts`

### RED

`frontend/miniapp/tests/unit/request.spec.ts`

```ts
import { describe, it, expect } from 'vitest'
import { buildUrl } from '../../src/utils/request'

describe('request', () => {
  it('builds url', () => {
    expect(buildUrl('/cruises')).toContain('/api/v1/cruises')
  })
})
```

### GREEN

`frontend/miniapp/src/utils/request.ts`

```ts
const BASE_URL = 'http://localhost:8080/api/v1'

export const buildUrl = (path: string) => `${BASE_URL}${path}`

export const request = <T>(path: string, data?: any, method: UniApp.RequestOptions['method'] = 'GET') => {
  return new Promise<T>((resolve, reject) => {
    uni.request({
      url: buildUrl(path),
      data,
      method,
      success: (res) => resolve(res.data as T),
      fail: (err) => reject(err),
    })
  })
}
```

`frontend/miniapp/src/stores/auth.ts`

```ts
import { defineStore } from 'pinia'

export const useAuthStore = defineStore('auth', {
  state: () => ({ token: '' }),
  actions: { setToken(token: string) { this.token = token } },
})
```

### REFACTOR

- 注入 baseUrl 到 env 配置。

### 验证

```bash
cd frontend/miniapp
pnpm test
```

---

# Part K CI（GitHub Actions）

## Task K1 - CI Pipeline

**Files：**
- Create: `.github/workflows/ci.yml`

### RED

触发 CI（预期失败，配置不存在）。

### GREEN

最小可运行 CI（示例）：

```yaml
name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:

jobs:
  backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: "1.23.x"
      - name: Test backend
        run: |
          cd backend
          go test ./... -coverprofile=coverage.out -covermode=atomic

  admin:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"
      - name: Install pnpm
        run: npm i -g pnpm
      - name: Test admin
        run: |
          cd frontend/admin
          pnpm install
          pnpm vitest run --coverage

  web:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"
      - name: Install pnpm
        run: npm i -g pnpm
      - name: Test web
        run: |
          cd frontend/web
          pnpm install
          pnpm vitest run --coverage

  miniapp:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"
      - name: Install pnpm
        run: npm i -g pnpm
      - name: Test miniapp
        run: |
          cd frontend/miniapp
          pnpm install
          pnpm test
```

### REFACTOR

- 缓存构建产物，加入 lint 与 format 校验。

### 验证

通过 GitHub Actions 查看。

---

# 全量回归验证

```bash
cd backend
go test ./... -coverprofile=coverage.out -covermode=atomic

cd ../frontend/admin
pnpm vitest run --coverage

cd ../web
pnpm vitest run --coverage

cd ../miniapp
pnpm test
```

---

## 交付物清单

- Monorepo + Docker dev 环境
- 后端基础能力 + Auth/JWT/RBAC
- 邮轮介绍模块全链路（Domain/Repo/Service/Handler）
- 迁移脚本 + Swagger 文档
- 共享类型包
- Admin/Web/Miniapp 基础页面与 API 适配
- CI 流水线
