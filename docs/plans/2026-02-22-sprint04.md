# Sprint 4: Payment + Orders + Notifications + Analytics Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add payments, order lifecycle, notifications, and analytics dashboards across backend/admin/web/miniapp.

**Architecture:** Introduce payment/refund domain, adapters for WeChat/Alipay, order status transitions, notification outbox, and reporting endpoints. Frontends surface payment and analytics views using Composition API.

**Tech Stack:** Go 1.26, Gin, GORM, PostgreSQL 17, Redis 7.4, Nuxt 4, Vue 3, Pinia, Vitest, Playwright, uni-app.

---

## Part A: Backend Payments + Orders (Tasks 1-6)

### Task 1: Payment + Refund Domain Models

**Files:**
- Create: `backend/internal/domain/payment.go`
- Create: `backend/internal/domain/refund.go`
- Test: `backend/internal/domain/payment_test.go`

**Step 1: Write the failing test**

Create `backend/internal/domain/payment_test.go`:

```go
package domain

import "testing"

func TestPaymentModelFields(t *testing.T) {
    p := Payment{OrderID: 1, AmountCents: 100}
    if p.AmountCents == 0 {
        t.Fatal("expected amount")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/domain -run TestPaymentModelFields -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/domain/payment.go`:

```go
package domain

import "time"

type Payment struct {
    ID int64 `gorm:"primaryKey"`
    OrderID int64 `gorm:"index"`
    Provider string `gorm:"size:20"`
    TradeNo string `gorm:"size:100"`
    AmountCents int64
    Status string `gorm:"size:20"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/refund.go`:

```go
package domain

import "time"

type Refund struct {
    ID int64 `gorm:"primaryKey"`
    PaymentID int64 `gorm:"index"`
    AmountCents int64
    Reason string `gorm:"size:200"`
    Status string `gorm:"size:20"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/domain -run TestPaymentModelFields -v`
Expected: PASS

**Step 5: Refactor (order id naming)**

Update `backend/internal/domain/payment.go`:

```go
type Payment struct {
    ID int64 `gorm:"primaryKey"`
    OrderID int64 `gorm:"index;column:order_id"`
    Provider string `gorm:"size:20"`
    TradeNo string `gorm:"size:100"`
    AmountCents int64
    Status string `gorm:"size:20"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Run: `cd backend && go test ./internal/domain -run TestPaymentModelFields -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/domain/payment.go backend/internal/domain/refund.go backend/internal/domain/payment_test.go
git commit -m "feat: add payment and refund domain models"
```

---

### Task 2: Payment + Notification Migrations

**Files:**
- Create: `backend/migrations/000004_payment_notify.up.sql`
- Create: `backend/migrations/000004_payment_notify.down.sql`
- Test: `backend/migrations/migrations_sprint4_test.go`

**Step 1: Write the failing test**

Create `backend/migrations/migrations_sprint4_test.go`:

```go
package migrations

import (
    "os"
    "testing"
)

func TestSprint4MigrationFilesExist(t *testing.T) {
    files := []string{
        "000004_payment_notify.up.sql",
        "000004_payment_notify.down.sql",
    }
    for _, f := range files {
        if _, err := os.Stat("migrations/" + f); err != nil {
            t.Fatalf("expected %s", f)
        }
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./migrations -run TestSprint4MigrationFilesExist -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/migrations/000004_payment_notify.up.sql`:

```sql
CREATE TABLE IF NOT EXISTS payments (
  id BIGSERIAL PRIMARY KEY,
  order_id BIGINT NOT NULL,
  provider VARCHAR(20) NOT NULL,
  trade_no VARCHAR(100),
  amount_cents BIGINT NOT NULL,
  status VARCHAR(20) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS refunds (
  id BIGSERIAL PRIMARY KEY,
  payment_id BIGINT NOT NULL REFERENCES payments(id),
  amount_cents BIGINT NOT NULL,
  reason VARCHAR(200),
  status VARCHAR(20) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS notifications (
  id BIGSERIAL PRIMARY KEY,
  user_id BIGINT,
  channel VARCHAR(20) NOT NULL,
  template VARCHAR(50) NOT NULL,
  payload TEXT NOT NULL,
  status VARCHAR(20) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

Create `backend/migrations/000004_payment_notify.down.sql`:

```sql
DROP TABLE IF EXISTS notifications;
DROP TABLE IF EXISTS refunds;
DROP TABLE IF EXISTS payments;
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./migrations -run TestSprint4MigrationFilesExist -v`
Expected: PASS

**Step 5: Refactor (indexes)**

Update `backend/migrations/000004_payment_notify.up.sql`:

```sql
CREATE INDEX IF NOT EXISTS idx_payments_order_id ON payments(order_id);
CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
```

Run: `cd backend && go test ./migrations -run TestSprint4MigrationFilesExist -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/migrations/000004_payment_notify.up.sql backend/migrations/000004_payment_notify.down.sql backend/migrations/migrations_sprint4_test.go
git commit -m "feat: add payment and notification schema"
```

---

### Task 3: Payment Service (WeChat + Alipay Adapters)

**Files:**
- Create: `backend/internal/service/payment_service.go`
- Create: `backend/internal/service/payment_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/payment_service_test.go`:

```go
package service

import "testing"

type fakeGateway struct{ called bool }
func (f *fakeGateway) CreatePay(_ int64, _ int64) (string, error) { f.called = true; return "pay_url", nil }

func TestPaymentServiceCreate(t *testing.T) {
    svc := NewPaymentService(&fakeGateway{})
    url, _ := svc.Create(1, 100)
    if url == "" {
        t.Fatal("expected pay url")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestPaymentServiceCreate -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/service/payment_service.go`:

```go
package service

type PaymentGateway interface {
    CreatePay(orderID int64, amountCents int64) (string, error)
}

type PaymentService struct { gw PaymentGateway }

func NewPaymentService(gw PaymentGateway) *PaymentService { return &PaymentService{gw: gw} }

func (s *PaymentService) Create(orderID int64, amountCents int64) (string, error) {
    return s.gw.CreatePay(orderID, amountCents)
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestPaymentServiceCreate -v`
Expected: PASS

**Step 5: Refactor (wechat/alipay gateway)**

Create `backend/internal/service/payment_gateway.go`:

```go
package service

type WechatGateway struct {}
func (w WechatGateway) CreatePay(orderID int64, amountCents int64) (string, error) { return "wechat://pay", nil }

type AlipayGateway struct {}
func (a AlipayGateway) CreatePay(orderID int64, amountCents int64) (string, error) { return "alipay://pay", nil }
```

Run: `cd backend && go test ./internal/service -run TestPaymentServiceCreate -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/service/payment_service.go backend/internal/service/payment_gateway.go backend/internal/service/payment_service_test.go
git commit -m "feat: add payment service with gateways"
```

---

### Task 4: Payment Callback + Order Status Transition

**Files:**
- Create: `backend/internal/handler/payment_handler.go`
- Modify: `backend/internal/handler/booking_handler.go`
- Test: `backend/internal/handler/payment_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/payment_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestPaymentCallback(t *testing.T) {
    r := gin.New()
    h := NewPaymentHandler(nil)
    r.POST("/api/pay/callback", h.Callback)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("POST", "/api/pay/callback", nil))
    if w.Code != http.StatusOK {
        t.Fatalf("expected 200, got %d", w.Code)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestPaymentCallback -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/handler/payment_handler.go`:

```go
package handler

import (
    "github.com/cruisebooking/backend/internal/pkg/response"
    "github.com/gin-gonic/gin"
)

type PaymentHandler struct {}
func NewPaymentHandler(_ interface{}) *PaymentHandler { return &PaymentHandler{} }

func (h *PaymentHandler) Callback(c *gin.Context) {
    response.Success(c, gin.H{"status": "paid"})
}
```

Modify `backend/internal/handler/booking_handler.go` to add `UpdateStatus` stub.

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestPaymentCallback -v`
Expected: PASS

**Step 5: Refactor (service wiring)**

Update `backend/internal/handler/payment_handler.go` to accept service interface:

```go
type PaymentCallbackService interface { HandleCallback(payload []byte) error }

type PaymentHandler struct { svc PaymentCallbackService }
func NewPaymentHandler(svc PaymentCallbackService) *PaymentHandler { return &PaymentHandler{svc: svc} }
```

Run: `cd backend && go test ./internal/handler -run TestPaymentCallback -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/handler/payment_handler.go backend/internal/handler/payment_handler_test.go backend/internal/handler/booking_handler.go
git commit -m "feat: add payment callback handler"
```

---

### Task 5: Refund Service + Handler

**Files:**
- Create: `backend/internal/service/refund_service.go`
- Create: `backend/internal/service/refund_service_test.go`
- Create: `backend/internal/handler/refund_handler.go`

**Step 1: Write the failing test**

Create `backend/internal/service/refund_service_test.go`:

```go
package service

import "testing"

type fakeRefundRepo struct{ called bool }
func (f *fakeRefundRepo) Create(_ interface{}) error { f.called = true; return nil }

func TestRefundServiceCreate(t *testing.T) {
    svc := NewRefundService(&fakeRefundRepo{})
    _ = svc.Create(1, 100, "cancel")
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestRefundServiceCreate -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/service/refund_service.go`:

```go
package service

type RefundRepo interface { Create(v interface{}) error }

type RefundService struct { repo RefundRepo }

func NewRefundService(repo RefundRepo) *RefundService { return &RefundService{repo: repo} }

func (s *RefundService) Create(paymentID int64, amountCents int64, reason string) error {
    return s.repo.Create(map[string]interface{}{"payment_id": paymentID, "amount": amountCents, "reason": reason})
}
```

Create `backend/internal/handler/refund_handler.go` with a `POST /api/refunds` stub returning success.

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestRefundServiceCreate -v`
Expected: PASS

**Step 5: Refactor (typed refund)**

Update `backend/internal/service/refund_service.go` to use `domain.Refund`.

**Step 6: Commit**

```bash
git add backend/internal/service/refund_service.go backend/internal/service/refund_service_test.go backend/internal/handler/refund_handler.go
git commit -m "feat: add refund service and handler"
```

---

### Task 6: Notification Service

**Files:**
- Create: `backend/internal/service/notify_service.go`
- Create: `backend/internal/service/notify_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/notify_service_test.go`:

```go
package service

import "testing"

type fakeNotifier struct{ called bool }
func (f *fakeNotifier) Send(_ string, _ string, _ string) error { f.called = true; return nil }

func TestNotifyServiceSend(t *testing.T) {
    svc := NewNotifyService(&fakeNotifier{})
    _ = svc.Send("sms", "template", "payload")
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestNotifyServiceSend -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/service/notify_service.go`:

```go
package service

type Notifier interface { Send(channel, template, payload string) error }

type NotifyService struct { n Notifier }

func NewNotifyService(n Notifier) *NotifyService { return &NotifyService{n: n} }

func (s *NotifyService) Send(channel, template, payload string) error {
    return s.n.Send(channel, template, payload)
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestNotifyServiceSend -v`
Expected: PASS

**Step 5: Refactor (channel constants)**

Add constants in `backend/internal/service/notify_service.go`:

```go
const (
    ChannelSMS = "sms"
    ChannelWechat = "wechat"
    ChannelInbox = "inbox"
)
```

Run: `cd backend && go test ./internal/service -run TestNotifyServiceSend -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/service/notify_service.go backend/internal/service/notify_service_test.go
git commit -m "feat: add notification service"
```

---

## Part B: Analytics (Task 7)

### Task 7: Analytics Service + Handler

**Files:**
- Create: `backend/internal/service/analytics_service.go`
- Create: `backend/internal/service/analytics_service_test.go`
- Create: `backend/internal/handler/analytics_handler.go`

**Step 1: Write the failing test**

Create `backend/internal/service/analytics_service_test.go`:

```go
package service

import "testing"

type fakeAnalyticsRepo struct{}
func (f fakeAnalyticsRepo) TodaySales() (int64, error) { return 1000, nil }

func TestAnalyticsTodaySales(t *testing.T) {
    svc := NewAnalyticsService(fakeAnalyticsRepo{})
    v, _ := svc.TodaySales()
    if v == 0 {
        t.Fatal("expected sales")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestAnalyticsTodaySales -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/service/analytics_service.go`:

```go
package service

type AnalyticsRepo interface { TodaySales() (int64, error) }

type AnalyticsService struct { repo AnalyticsRepo }

func NewAnalyticsService(repo AnalyticsRepo) *AnalyticsService { return &AnalyticsService{repo: repo} }

func (s *AnalyticsService) TodaySales() (int64, error) { return s.repo.TodaySales() }
```

Create `backend/internal/handler/analytics_handler.go` with `/admin/analytics/summary` returning stub.

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestAnalyticsTodaySales -v`
Expected: PASS

**Step 5: Refactor (add weekly trend)**

Update `backend/internal/service/analytics_service.go`:

```go
func (s *AnalyticsService) WeeklyTrend() ([]int64, error) { return []int64{1,2,3}, nil }
```

Run: `cd backend && go test ./internal/service -run TestAnalyticsTodaySales -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/service/analytics_service.go backend/internal/service/analytics_service_test.go backend/internal/handler/analytics_handler.go
git commit -m "feat: add analytics service and handler"
```

---

## Part C: Admin (Task 8)

> Follow @vue-best-practices and @vue-testing-best-practices. Use `<script setup lang="ts">`.

### Task 8: Admin Dashboard + Finance

**Files:**
- Create: `frontend/admin/pages/dashboard/index.vue`
- Create: `frontend/admin/pages/finance/index.vue`
- Test: `frontend/admin/tests/unit/dashboard.page.spec.ts`

**Step 1: Write the failing test**

Create `frontend/admin/tests/unit/dashboard.page.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Page from '../../pages/dashboard/index.vue'

describe('Dashboard', () => {
  it('shows summary title', () => {
    const wrapper = mount(Page)
    expect(wrapper.text()).toContain('Dashboard')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/admin && pnpm vitest run tests/unit/dashboard.page.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/admin/pages/dashboard/index.vue`:

```vue
<script setup lang="ts">
const summary = { sales: 1000, orders: 12 }
</script>

<template>
  <div class="page">
    <h1>Dashboard</h1>
    <div>Sales: {{ summary.sales }}</div>
    <div>Orders: {{ summary.orders }}</div>
  </div>
</template>
```

Create `frontend/admin/pages/finance/index.vue` with basic table.

**Step 4: Run test to verify it passes**

Run: `cd frontend/admin && pnpm vitest run tests/unit/dashboard.page.spec.ts`
Expected: PASS

**Step 5: Refactor (extract stat card)**

Create `frontend/admin/components/StatCard.vue` and use it on dashboard.

**Step 6: Commit**

```bash
git add frontend/admin/pages/dashboard/index.vue frontend/admin/pages/finance/index.vue frontend/admin/components/StatCard.vue frontend/admin/tests/unit/dashboard.page.spec.ts
git commit -m "feat: add admin dashboard and finance pages"
```

---

## Part D: Web + Miniapp (Tasks 9-10)

> Follow @vue-best-practices and @vue-testing-best-practices. Use `<script setup lang="ts">`.

### Task 9: Web Payment + Order Detail

**Files:**
- Create: `frontend/web/pages/orders/[id].vue`
- Create: `frontend/web/pages/pay/[id].vue`
- Test: `frontend/web/tests/unit/pay.page.spec.ts`

**Step 1: Write the failing test**

Create `frontend/web/tests/unit/pay.page.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Page from '../../pages/pay/[id].vue'

describe('Pay Page', () => {
  it('renders pay button', () => {
    const wrapper = mount(Page)
    expect(wrapper.text()).toContain('Pay Now')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/web && pnpm vitest run tests/unit/pay.page.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/web/pages/pay/[id].vue`:

```vue
<template>
  <div class="page">
    <h1>Payment</h1>
    <button>Pay Now</button>
  </div>
</template>
```

Create `frontend/web/pages/orders/[id].vue` with a simple status view.

**Step 4: Run test to verify it passes**

Run: `cd frontend/web && pnpm vitest run tests/unit/pay.page.spec.ts`
Expected: PASS

**Step 5: Refactor (extract pay button)**

Create `frontend/web/components/PayButton.vue` and use it on pay page.

**Step 6: Commit**

```bash
git add frontend/web/pages/pay/[id].vue frontend/web/pages/orders/[id].vue frontend/web/components/PayButton.vue frontend/web/tests/unit/pay.page.spec.ts
git commit -m "feat: add web payment and order pages"
```

---

### Task 10: Miniapp Payment Page

**Files:**
- Create: `frontend/miniapp/pages/pay/pay.vue`
- Test: `frontend/miniapp/tests/pay.spec.ts`

**Step 1: Write the failing test**

Create `frontend/miniapp/tests/pay.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/vue'
import Pay from '../pages/pay/pay.vue'

describe('Miniapp Pay', () => {
  it('shows pay label', () => {
    const { getByText } = render(Pay)
    expect(getByText('Pay Now')).toBeTruthy()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/miniapp && pnpm vitest run tests/pay.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/miniapp/pages/pay/pay.vue`:

```vue
<template>
  <view class="page">
    <text>Pay Now</text>
  </view>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/miniapp && pnpm vitest run tests/pay.spec.ts`
Expected: PASS

**Step 5: Refactor (shared pay button)**

Create `frontend/miniapp/components/PayButton.vue` and use it in pay page.

**Step 6: Commit**

```bash
git add frontend/miniapp/pages/pay/pay.vue frontend/miniapp/components/PayButton.vue frontend/miniapp/tests/pay.spec.ts
git commit -m "feat: add miniapp payment page"
```

---

## Part E: CI (Task 11)

### Task 11: CI for Payment + Analytics

**Files:**
- Modify: `.github/workflows/ci.yml`

**Step 1: Write the failing test**

Add a backend analytics test step (initially missing) and expect CI to fail.

**Step 2: Run test to verify it fails**

Run: `act -j test-backend` and expect missing step failure.

**Step 3: Write minimal implementation**

Update `.github/workflows/ci.yml`:

```yaml
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with: { go-version: '1.26' }
      - run: cd backend && go test ./... -coverprofile=coverage.out -covermode=atomic
```

**Step 4: Run test to verify it passes**

Run: `act -j test-backend`
Expected: PASS

**Step 5: Refactor (cache go modules)**

Add `actions/cache` for Go modules.

**Step 6: Commit**

```bash
git add .github/workflows/ci.yml
git commit -m "ci: add backend tests for sprint4"
```

---

## Final Verification

Run:

```bash
cd backend && go test ./... -coverprofile=coverage.out -covermode=atomic
cd frontend/admin && pnpm vitest run
cd frontend/web && pnpm vitest run
cd frontend/miniapp && pnpm vitest run
```

Expected: All tests pass and coverage remains at 100%.
