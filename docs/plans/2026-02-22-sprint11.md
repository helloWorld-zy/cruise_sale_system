# Sprint 11: 智能运营（上）Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 实现动态定价、渠道库存分配与预警系统基础能力。

**Architecture:** 后端新增定价规则、渠道库存与预警规则模型，提供定价服务与预警接口；后台配置与监控；前台展示价格提示。TDD驱动最小实现。

**Tech Stack:** Go 1.26, Gin, GORM, PostgreSQL, Nuxt 4 (admin/web), Vue 3, Pinia, Vitest, Playwright, uni-app.

---

## Part A: Backend (Tasks 1-4)

### Task 1: 定价与库存领域模型

**Files:**
- Create: `backend/internal/domain/pricing_rule.go`
- Create: `backend/internal/domain/channel_inventory.go`
- Create: `backend/internal/domain/alert_rule.go`
- Test: `backend/internal/domain/ops_domain_test.go`

**Step 1: Write the failing test**

Create `backend/internal/domain/ops_domain_test.go`:

```go
package domain

import "testing"

func TestPricingRuleModel(t *testing.T) {
    r := PricingRule{Name: "EarlyBird", BasePrice: 1000}
    if r.Name == "" || r.BasePrice == 0 {
        t.Fatal("expected pricing rule fields")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/domain -run TestPricingRuleModel -v`
Expected: FAIL with "undefined: PricingRule"

**Step 3: Write minimal implementation**

Create `backend/internal/domain/pricing_rule.go`:

```go
package domain

import "time"

type PricingRule struct {
    ID int64 `gorm:"primaryKey"`
    Name string `gorm:"size:100"`
    BasePrice int64
    DemandFactor float64
    StockFactor float64
    Status int16 `gorm:"default:1"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/channel_inventory.go`:

```go
package domain

import "time"

type ChannelInventory struct {
    ID int64 `gorm:"primaryKey"`
    CabinID int64
    Channel string `gorm:"size:50"` // direct, ota, agency
    Total int
    Reserved int
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/alert_rule.go`:

```go
package domain

import "time"

type AlertRule struct {
    ID int64 `gorm:"primaryKey"`
    Name string `gorm:"size:100"`
    Metric string `gorm:"size:50"` // stock, price, demand
    Threshold float64
    Status int16 `gorm:"default:1"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/domain -run TestPricingRuleModel -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/domain/pricing_rule.go backend/internal/domain/channel_inventory.go backend/internal/domain/alert_rule.go backend/internal/domain/ops_domain_test.go
git commit -m "feat: add pricing, channel inventory, and alert models"
```

---

### Task 2: 定价服务

**Files:**
- Create: `backend/internal/service/pricing_service.go`
- Test: `backend/internal/service/pricing_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/pricing_service_test.go`:

```go
package service

import "testing"

func TestCalcPrice(t *testing.T) {
    svc := NewPricingService()
    price := svc.CalcPrice(1000, 1.1, 0.9)
    if price <= 0 {
        t.Fatal("expected price")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestCalcPrice -v`
Expected: FAIL with "undefined: NewPricingService"

**Step 3: Write minimal implementation**

Create `backend/internal/service/pricing_service.go`:

```go
package service

type PricingService struct{}

func NewPricingService() *PricingService { return &PricingService{} }

func (s *PricingService) CalcPrice(base int64, demandFactor, stockFactor float64) int64 {
    v := float64(base) * demandFactor * stockFactor
    if v < 1 {
        v = 1
    }
    return int64(v)
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestCalcPrice -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/service/pricing_service.go backend/internal/service/pricing_service_test.go
git commit -m "feat: add pricing service"
```

---

### Task 3: 预警服务与处理器

**Files:**
- Create: `backend/internal/service/alert_service.go`
- Create: `backend/internal/handler/alert_handler.go`
- Test: `backend/internal/handler/alert_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/alert_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

type fakeAlertSvc struct{}
func (fakeAlertSvc) List() []string { return []string{"stock-low"} }

func TestAlertListAPI(t *testing.T) {
    r := gin.New()
    h := NewAlertHandler(fakeAlertSvc{})
    r.GET("/alerts", h.List)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("GET", "/alerts", nil))
    if w.Code != http.StatusOK { t.Fatalf("expected 200, got %d", w.Code) }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestAlertListAPI -v`
Expected: FAIL with "undefined: NewAlertHandler"

**Step 3: Write minimal implementation**

Create `backend/internal/service/alert_service.go`:

```go
package service

type AlertService struct{}

func NewAlertService() *AlertService { return &AlertService{} }

func (s *AlertService) List() []string { return []string{} }
```

Create `backend/internal/handler/alert_handler.go`:

```go
package handler

import "github.com/gin-gonic/gin"

type AlertService interface { List() []string }

type AlertHandler struct{ svc AlertService }

func NewAlertHandler(svc AlertService) *AlertHandler { return &AlertHandler{svc: svc} }

func (h *AlertHandler) List(c *gin.Context) { c.JSON(200, gin.H{"items": h.svc.List()}) }
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestAlertListAPI -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/service/alert_service.go backend/internal/handler/alert_handler.go backend/internal/handler/alert_handler_test.go
git commit -m "feat: add alert service and handler"
```

---

### Task 4: 渠道库存分配接口

**Files:**
- Create: `backend/internal/handler/channel_inventory_handler.go`
- Test: `backend/internal/handler/channel_inventory_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/channel_inventory_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestChannelInventoryListAPI(t *testing.T) {
    r := gin.New()
    h := NewChannelInventoryHandler()
    r.GET("/channel-inventory", h.List)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("GET", "/channel-inventory", nil))
    if w.Code != http.StatusOK { t.Fatalf("expected 200, got %d", w.Code) }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestChannelInventoryListAPI -v`
Expected: FAIL with "undefined: NewChannelInventoryHandler"

**Step 3: Write minimal implementation**

Create `backend/internal/handler/channel_inventory_handler.go`:

```go
package handler

import "github.com/gin-gonic/gin"

type ChannelInventoryHandler struct{}

func NewChannelInventoryHandler() *ChannelInventoryHandler { return &ChannelInventoryHandler{} }

func (h *ChannelInventoryHandler) List(c *gin.Context) { c.JSON(200, gin.H{"items": []string{}}) }
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestChannelInventoryListAPI -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/handler/channel_inventory_handler.go backend/internal/handler/channel_inventory_handler_test.go
git commit -m "feat: add channel inventory handler"
```

---

## Part B: Admin (Task 5)

> Follow @vue-best-practices and @vue-testing-best-practices.

### Task 5: 定价规则配置页面

**Files:**
- Create: `frontend/admin/pages/ops/pricing-rules.vue`
- Test: `frontend/admin/tests/unit/ops/pricing-rules.spec.ts`

**Step 1: Write the failing test**

Create `frontend/admin/tests/unit/ops/pricing-rules.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import PricingRulesPage from '@/pages/ops/pricing-rules.vue'

describe('PricingRulesPage', () => {
  it('renders heading', () => {
    const wrapper = mount(PricingRulesPage)
    expect(wrapper.text()).toContain('Pricing Rules')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/admin && pnpm vitest run tests/unit/ops/pricing-rules.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/admin/pages/ops/pricing-rules.vue`:

```vue
<script setup lang="ts">
const items = ref([{ id: 1, name: 'EarlyBird', basePrice: 1000 }])
</script>

<template>
  <section>
    <h1>Pricing Rules</h1>
    <ul>
      <li v-for="r in items" :key="r.id">{{ r.name }} - {{ r.basePrice }}</li>
    </ul>
  </section>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/admin && pnpm vitest run tests/unit/ops/pricing-rules.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/admin/pages/ops/pricing-rules.vue frontend/admin/tests/unit/ops/pricing-rules.spec.ts
git commit -m "feat: add pricing rules admin page"
```

---

## Part C: Web (Task 6)

### Task 6: 价格提示组件

**Files:**
- Create: `frontend/web/components/PriceHint.vue`
- Test: `frontend/web/tests/unit/price-hint.spec.ts`

**Step 1: Write the failing test**

Create `frontend/web/tests/unit/price-hint.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import PriceHint from '@/components/PriceHint.vue'

describe('PriceHint', () => {
  it('renders label', () => {
    const wrapper = mount(PriceHint, { props: { text: 'Price updated' } })
    expect(wrapper.text()).toContain('Price updated')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/web && pnpm vitest run tests/unit/price-hint.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/web/components/PriceHint.vue`:

```vue
<script setup lang="ts">
defineProps<{ text: string }>()
</script>

<template>
  <div>{{ text }}</div>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/web && pnpm vitest run tests/unit/price-hint.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/web/components/PriceHint.vue frontend/web/tests/unit/price-hint.spec.ts
git commit -m "feat: add price hint component"
```

---

## Part D: Miniapp (Task 7)

### Task 7: 小程序库存预警展示

**Files:**
- Create: `frontend/miniapp/pages/alerts/alerts.vue`
- Test: `frontend/miniapp/tests/alerts.spec.ts`

**Step 1: Write the failing test**

Create `frontend/miniapp/tests/alerts.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import AlertsPage from '@/pages/alerts/alerts.vue'

describe('AlertsPage', () => {
  it('exists', () => {
    expect(AlertsPage).toBeTruthy()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/miniapp && pnpm vitest run tests/alerts.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/miniapp/pages/alerts/alerts.vue`:

```vue
<script setup lang="ts">
const items = ref<string[]>([])
</script>

<template>
  <view>
    <text>Alerts</text>
    <view v-for="a in items" :key="a">{{ a }}</view>
  </view>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/miniapp && pnpm vitest run tests/alerts.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/miniapp/pages/alerts/alerts.vue frontend/miniapp/tests/alerts.spec.ts
git commit -m "feat: add miniapp alerts page"
```

---

## Part E: CI (Task 8)

### Task 8: Ops Coverage Gate in CI

**Files:**
- Modify: `.github/workflows/backend.yml`

**Step 1: Write the failing test**

Create `scripts/verify_ops_ci_test.go`:

```go
package scripts

import (
    "os"
    "testing"
)

func TestOpsCIWorkflowExists(t *testing.T) {
    if _, err := os.Stat(".github/workflows/backend.yml"); err != nil {
        t.Fatal("expected backend workflow")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./scripts -run TestOpsCIWorkflowExists -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Ensure backend workflow runs `go test ./... -coverprofile=coverage.out -covermode=atomic -v`.

**Step 4: Run test to verify it passes**

Run: `go test ./scripts -run TestOpsCIWorkflowExists -v`
Expected: PASS

**Step 5: Commit**

```bash
git add .github/workflows/backend.yml scripts/verify_ops_ci_test.go
git commit -m "chore: enforce ops coverage in CI"
```

---

## Final Verification

Run:

```bash
cd backend && go test ./... -coverprofile=coverage.out -covermode=atomic -v
cd frontend/admin && pnpm vitest run --coverage && pnpm playwright test
cd frontend/web && pnpm vitest run --coverage && pnpm playwright test
cd frontend/miniapp && pnpm vitest run --coverage
```

Expected: All tests pass and coverage is 100%.
