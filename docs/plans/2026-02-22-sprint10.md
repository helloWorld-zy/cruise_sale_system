# Sprint 10: 评价 + 游记社区 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 实现评价系统与游记社区（发布、审核、互动），并提供拼团出行的基础流程。

**Architecture:** 后端新增评价、游记、拼团领域模型与服务；后台配置与审核；Web/小程序支持发布与浏览。TDD驱动，最小实现。

**Tech Stack:** Go 1.26, Gin, GORM, PostgreSQL, Nuxt 4 (admin/web), Vue 3, Pinia, Vitest, Playwright, uni-app.

---

## Part A: Backend (Tasks 1-4)

### Task 1: Review/TravelNote/GroupTrip 域模型

**Files:**
- Create: `backend/internal/domain/review.go`
- Create: `backend/internal/domain/travel_note.go`
- Create: `backend/internal/domain/group_trip.go`
- Test: `backend/internal/domain/community_domain_test.go`

**Step 1: Write the failing test**

Create `backend/internal/domain/community_domain_test.go`:

```go
package domain

import "testing"

func TestReviewModel(t *testing.T) {
    r := Review{Score: 5, Content: "great"}
    if r.Score != 5 || r.Content == "" {
        t.Fatal("expected review fields")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/domain -run TestReviewModel -v`
Expected: FAIL with "undefined: Review"

**Step 3: Write minimal implementation**

Create `backend/internal/domain/review.go`:

```go
package domain

import "time"

type Review struct {
    ID int64 `gorm:"primaryKey"`
    OrderID int64
    UserID int64
    Score int
    Content string `gorm:"type:text"`
    MediaURLs string `gorm:"type:text"`
    Status int16 `gorm:"default:0"` // 0 pending, 1 approved
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/travel_note.go`:

```go
package domain

import "time"

type TravelNote struct {
    ID int64 `gorm:"primaryKey"`
    UserID int64
    Title string `gorm:"size:200"`
    Content string `gorm:"type:text"`
    CoverURL string `gorm:"size:500"`
    LikeCount int64
    Status int16 `gorm:"default:0"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/group_trip.go`:

```go
package domain

import "time"

type GroupTrip struct {
    ID int64 `gorm:"primaryKey"`
    CruiseID int64
    LeaderUserID int64
    TargetSize int
    CurrentSize int
    Status int16 `gorm:"default:0"` // 0 recruiting, 1 formed
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/domain -run TestReviewModel -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/domain/review.go backend/internal/domain/travel_note.go backend/internal/domain/group_trip.go backend/internal/domain/community_domain_test.go
git commit -m "feat: add review, travel note, and group trip models"
```

---

### Task 2: Community Repositories

**Files:**
- Create: `backend/internal/repository/review_repo.go`
- Create: `backend/internal/repository/travel_note_repo.go`
- Test: `backend/internal/repository/community_repo_test.go`

**Step 1: Write the failing test**

Create `backend/internal/repository/community_repo_test.go`:

```go
package repository

import (
    "testing"

    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func TestReviewRepoCreate(t *testing.T) {
    db, _ := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    _ = db.AutoMigrate(&domain.Review{})
    repo := NewReviewRepository(db)
    err := repo.Create(&domain.Review{Score: 5, Content: "ok"})
    if err != nil { t.Fatal(err) }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/repository -run TestReviewRepoCreate -v`
Expected: FAIL with "undefined: NewReviewRepository"

**Step 3: Write minimal implementation**

Create `backend/internal/repository/review_repo.go`:

```go
package repository

import (
    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/gorm"
)

type ReviewRepository struct{ db *gorm.DB }
func NewReviewRepository(db *gorm.DB) *ReviewRepository { return &ReviewRepository{db: db} }
func (r *ReviewRepository) Create(v *domain.Review) error { return r.db.Create(v).Error }
```

Create `backend/internal/repository/travel_note_repo.go`:

```go
package repository

import (
    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/gorm"
)

type TravelNoteRepository struct{ db *gorm.DB }
func NewTravelNoteRepository(db *gorm.DB) *TravelNoteRepository { return &TravelNoteRepository{db: db} }
func (r *TravelNoteRepository) Create(v *domain.TravelNote) error { return r.db.Create(v).Error }
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/repository -run TestReviewRepoCreate -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/repository/review_repo.go backend/internal/repository/travel_note_repo.go backend/internal/repository/community_repo_test.go
git commit -m "feat: add community repositories"
```

---

### Task 3: Review/TravelNote Services

**Files:**
- Create: `backend/internal/service/review_service.go`
- Create: `backend/internal/service/travel_note_service.go`
- Test: `backend/internal/service/community_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/community_service_test.go`:

```go
package service

import "testing"

type fakeReviewRepo struct{}
func (fakeReviewRepo) Create(*ReviewDTO) error { return nil }

func TestSubmitReview(t *testing.T) {
    svc := NewReviewService(fakeReviewRepo{})
    if err := svc.Submit(ReviewDTO{Score: 5, Content: "ok"}); err != nil {
        t.Fatal(err)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestSubmitReview -v`
Expected: FAIL with "undefined: NewReviewService"

**Step 3: Write minimal implementation**

Create `backend/internal/service/review_service.go`:

```go
package service

type ReviewDTO struct {
    Score int
    Content string
}

type ReviewRepo interface { Create(*ReviewDTO) error }

type ReviewService struct{ repo ReviewRepo }

func NewReviewService(repo ReviewRepo) *ReviewService { return &ReviewService{repo: repo} }

func (s *ReviewService) Submit(dto ReviewDTO) error { return s.repo.Create(&dto) }
```

Create `backend/internal/service/travel_note_service.go`:

```go
package service

type TravelNoteDTO struct {
    Title string
    Content string
}

type TravelNoteRepo interface { Create(*TravelNoteDTO) error }

type TravelNoteService struct{ repo TravelNoteRepo }

func NewTravelNoteService(repo TravelNoteRepo) *TravelNoteService { return &TravelNoteService{repo: repo} }

func (s *TravelNoteService) Publish(dto TravelNoteDTO) error { return s.repo.Create(&dto) }
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestSubmitReview -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/service/review_service.go backend/internal/service/travel_note_service.go backend/internal/service/community_service_test.go
git commit -m "feat: add review and travel note services"
```

---

### Task 4: Community API Handlers

**Files:**
- Create: `backend/internal/handler/community_handler.go`
- Test: `backend/internal/handler/community_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/community_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "strings"
    "testing"

    "github.com/gin-gonic/gin"
)

type fakeReviewService struct{}
func (fakeReviewService) Submit(_ ReviewDTO) error { return nil }

func TestSubmitReviewAPI(t *testing.T) {
    r := gin.New()
    h := NewCommunityHandler(fakeReviewService{})
    r.POST("/reviews", h.SubmitReview)
    w := httptest.NewRecorder()
    req := httptest.NewRequest("POST", "/reviews", strings.NewReader(`{"score":5,"content":"ok"}`))
    req.Header.Set("Content-Type", "application/json")
    r.ServeHTTP(w, req)
    if w.Code != http.StatusOK { t.Fatalf("expected 200, got %d", w.Code) }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestSubmitReviewAPI -v`
Expected: FAIL with "undefined: NewCommunityHandler"

**Step 3: Write minimal implementation**

Create `backend/internal/handler/community_handler.go`:

```go
package handler

import "github.com/gin-gonic/gin"

type ReviewDTO struct {
    Score int `json:"score"`
    Content string `json:"content"`
}

type ReviewService interface { Submit(ReviewDTO) error }

type CommunityHandler struct{ reviewSvc ReviewService }

func NewCommunityHandler(reviewSvc ReviewService) *CommunityHandler {
    return &CommunityHandler{reviewSvc: reviewSvc}
}

func (h *CommunityHandler) SubmitReview(c *gin.Context) {
    var dto ReviewDTO
    _ = c.ShouldBindJSON(&dto)
    _ = h.reviewSvc.Submit(dto)
    c.JSON(200, gin.H{"ok": true})
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestSubmitReviewAPI -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/handler/community_handler.go backend/internal/handler/community_handler_test.go
git commit -m "feat: add community review handler"
```

---

## Part B: Admin (Task 5)

> Follow @vue-best-practices and @vue-testing-best-practices.

### Task 5: 评价审核列表

**Files:**
- Create: `frontend/admin/pages/community/reviews.vue`
- Test: `frontend/admin/tests/unit/community/reviews.spec.ts`

**Step 1: Write the failing test**

Create `frontend/admin/tests/unit/community/reviews.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import ReviewsPage from '@/pages/community/reviews.vue'

describe('ReviewsPage', () => {
  it('renders review heading', () => {
    const wrapper = mount(ReviewsPage)
    expect(wrapper.text()).toContain('Review Moderation')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/admin && pnpm vitest run tests/unit/community/reviews.spec.ts`
Expected: FAIL (file missing)

**Step 3: Write minimal implementation**

Create `frontend/admin/pages/community/reviews.vue`:

```vue
<script setup lang="ts">
const items = ref([{ id: 1, score: 5, content: 'ok' }])
</script>

<template>
  <section>
    <h1>Review Moderation</h1>
    <ul>
      <li v-for="r in items" :key="r.id">{{ r.score }} - {{ r.content }}</li>
    </ul>
  </section>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/admin && pnpm vitest run tests/unit/community/reviews.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/admin/pages/community/reviews.vue frontend/admin/tests/unit/community/reviews.spec.ts
git commit -m "feat: add admin review moderation page"
```

---

## Part C: Web (Task 6)

### Task 6: 游记发布页

**Files:**
- Create: `frontend/web/pages/community/new.vue`
- Test: `frontend/web/tests/unit/community-new.spec.ts`

**Step 1: Write the failing test**

Create `frontend/web/tests/unit/community-new.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import CommunityNewPage from '@/pages/community/new.vue'

describe('CommunityNewPage', () => {
  it('renders publish form', () => {
    const wrapper = mount(CommunityNewPage)
    expect(wrapper.text()).toContain('Publish Travel Note')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/web && pnpm vitest run tests/unit/community-new.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/web/pages/community/new.vue`:

```vue
<script setup lang="ts">
const title = ref('')
const content = ref('')
</script>

<template>
  <section>
    <h1>Publish Travel Note</h1>
    <input v-model="title" placeholder="Title" />
    <textarea v-model="content" placeholder="Content"></textarea>
  </section>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/web && pnpm vitest run tests/unit/community-new.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/web/pages/community/new.vue frontend/web/tests/unit/community-new.spec.ts
git commit -m "feat: add web travel note publish page"
```

---

## Part D: Miniapp (Task 7)

### Task 7: 小程序评价入口

**Files:**
- Create: `frontend/miniapp/pages/review/review.vue`
- Test: `frontend/miniapp/tests/review.spec.ts`

**Step 1: Write the failing test**

Create `frontend/miniapp/tests/review.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import ReviewPage from '@/pages/review/review.vue'

describe('ReviewPage', () => {
  it('exists', () => {
    expect(ReviewPage).toBeTruthy()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/miniapp && pnpm vitest run tests/review.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/miniapp/pages/review/review.vue`:

```vue
<script setup lang="ts">
const score = ref(5)
const content = ref('')
</script>

<template>
  <view>
    <text>Review</text>
    <input v-model="score" type="number" />
    <textarea v-model="content"></textarea>
  </view>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/miniapp && pnpm vitest run tests/review.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/miniapp/pages/review/review.vue frontend/miniapp/tests/review.spec.ts
git commit -m "feat: add miniapp review page"
```

---

## Part E: CI (Task 8)

### Task 8: Community Test Coverage in CI

**Files:**
- Modify: `.github/workflows/backend.yml`
- Modify: `.github/workflows/web.yml`

**Step 1: Write the failing test**

Create `scripts/verify_community_ci_test.go`:

```go
package scripts

import (
    "os"
    "testing"
)

func TestCommunityCIWorkflowsExist(t *testing.T) {
    files := []string{
        ".github/workflows/backend.yml",
        ".github/workflows/web.yml",
    }
    for _, f := range files {
        if _, err := os.Stat(f); err != nil {
            t.Fatalf("expected %s to exist", f)
        }
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./scripts -run TestCommunityCIWorkflowsExist -v`
Expected: FAIL (files missing or not updated)

**Step 3: Write minimal implementation**

Add coverage commands to workflows to ensure 100% coverage.

**Step 4: Run test to verify it passes**

Run: `go test ./scripts -run TestCommunityCIWorkflowsExist -v`
Expected: PASS

**Step 5: Commit**

```bash
git add .github/workflows scripts/verify_community_ci_test.go
git commit -m "chore: enforce community coverage in CI"
```

---

## Final Verification

Run:

```bash
cd backend && go test ./... -coverprofile=coverage.out -covermode=atomic -v
cd frontend/admin && pnpm vitest run --coverage && pnpm playwright test
cd frontend/web && pnpm vitest run --coverage && pnpm playwright test
cd frontend/miniapp && pnpm vitest run --coverage
```

Expected: All tests pass and coverage is 100%.
