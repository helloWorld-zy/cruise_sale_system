# Sprint 2: Cabin Product Management Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deliver cabin product management with routes, voyages, cabin SKU pricing matrix, inventory, and search across backend/admin/web/miniapp.

**Architecture:** Keep backend layered (handler -> service -> repository -> domain) with SQL migrations and Meilisearch indexing. Frontends use Nuxt 4 (admin/web) and uni-app (miniapp) with Composition API and shared types.

**Tech Stack:** Go 1.26, Gin, GORM, PostgreSQL 17, Meilisearch, Redis 7.4, Nuxt 4, Vue 3, Pinia, Vitest, Playwright, uni-app.

---

## Part A: Backend Domain + Storage (Tasks 1-5)

### Task 1: Route/Voyage/Cabin Domain Models

**Files:**
- Create: `backend/internal/domain/route.go`
- Create: `backend/internal/domain/voyage.go`
- Create: `backend/internal/domain/cabin.go`
- Test: `backend/internal/domain/route_test.go`

**Step 1: Write the failing test**

Create `backend/internal/domain/route_test.go`:

```go
package domain

import "testing"

func TestRouteModelFields(t *testing.T) {
    r := Route{Code: "ASIA-001", Name: "Asia Loop"}
    if r.Code == "" || r.Name == "" {
        t.Fatal("expected route fields")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/domain -run TestRouteModelFields -v`
Expected: FAIL with "undefined: Route"

**Step 3: Write minimal implementation**

Create `backend/internal/domain/route.go`:

```go
package domain

import "time"

type Route struct {
    ID int64 `gorm:"primaryKey"`
    Code string `gorm:"size:50;uniqueIndex"`
    Name string `gorm:"size:200"`
    Description string `gorm:"type:text"`
    Status int16 `gorm:"default:1"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/voyage.go`:

```go
package domain

import "time"

type Voyage struct {
    ID int64 `gorm:"primaryKey"`
    RouteID int64 `gorm:"index"`
    CruiseID int64 `gorm:"index"`
    Code string `gorm:"size:50;uniqueIndex"`
    DepartDate time.Time
    ReturnDate time.Time
    Status int16 `gorm:"default:1"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/cabin.go`:

```go
package domain

import "time"

type CabinSKU struct {
    ID int64 `gorm:"primaryKey"`
    VoyageID int64 `gorm:"index"`
    CabinTypeID int64 `gorm:"index"`
    Code string `gorm:"size:80;uniqueIndex"`
    Deck string `gorm:"size:20"`
    Area float64
    MaxGuests int
    Status int16 `gorm:"default:1"`
    CreatedAt time.Time
    UpdatedAt time.Time
}

type CabinPrice struct {
    ID int64 `gorm:"primaryKey"`
    CabinSKUID int64 `gorm:"index"`
    Date time.Time `gorm:"index"`
    Occupancy int
    PriceCents int64
    CreatedAt time.Time
    UpdatedAt time.Time
}

type CabinInventory struct {
    ID int64 `gorm:"primaryKey"`
    CabinSKUID int64 `gorm:"uniqueIndex"`
    Total int
    Locked int
    Sold int
    UpdatedAt time.Time
}

type InventoryLog struct {
    ID int64 `gorm:"primaryKey"`
    CabinSKUID int64 `gorm:"index"`
    Change int
    Reason string `gorm:"size:200"`
    CreatedAt time.Time
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/domain -run TestRouteModelFields -v`
Expected: PASS

**Step 5: Refactor (naming consistency)**

Update `backend/internal/domain/cabin.go` to keep cents fields consistently named:

```go
type CabinPrice struct {
    ID int64 `gorm:"primaryKey"`
    CabinSKUID int64 `gorm:"index"`
    Date time.Time `gorm:"index"`
    Occupancy int
    PriceCents int64 `gorm:"column:price_cents"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Run: `cd backend && go test ./internal/domain -run TestRouteModelFields -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/domain/route.go backend/internal/domain/voyage.go backend/internal/domain/cabin.go backend/internal/domain/route_test.go
git commit -m "feat: add route voyage and cabin domain models"
```

---

### Task 2: SQL Migrations for Routes/Voyages/Cabins

**Files:**
- Create: `backend/migrations/000002_route_voyage_cabin.up.sql`
- Create: `backend/migrations/000002_route_voyage_cabin.down.sql`
- Test: `backend/migrations/migrations_sprint2_test.go`

**Step 1: Write the failing test**

Create `backend/migrations/migrations_sprint2_test.go`:

```go
package migrations

import (
    "os"
    "testing"
)

func TestSprint2MigrationFilesExist(t *testing.T) {
    files := []string{
        "000002_route_voyage_cabin.up.sql",
        "000002_route_voyage_cabin.down.sql",
    }
    for _, f := range files {
        if _, err := os.Stat("migrations/" + f); err != nil {
            t.Fatalf("expected %s", f)
        }
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./migrations -run TestSprint2MigrationFilesExist -v`
Expected: FAIL with "expected 000002_route_voyage_cabin.up.sql"

**Step 3: Write minimal implementation**

Create `backend/migrations/000002_route_voyage_cabin.up.sql`:

```sql
CREATE TABLE IF NOT EXISTS routes (
  id BIGSERIAL PRIMARY KEY,
  code VARCHAR(50) UNIQUE NOT NULL,
  name VARCHAR(200) NOT NULL,
  description TEXT,
  status SMALLINT DEFAULT 1,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS voyages (
  id BIGSERIAL PRIMARY KEY,
  route_id BIGINT NOT NULL REFERENCES routes(id),
  cruise_id BIGINT NOT NULL,
  code VARCHAR(50) UNIQUE NOT NULL,
  depart_date TIMESTAMP NOT NULL,
  return_date TIMESTAMP NOT NULL,
  status SMALLINT DEFAULT 1,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS cabin_skus (
  id BIGSERIAL PRIMARY KEY,
  voyage_id BIGINT NOT NULL REFERENCES voyages(id),
  cabin_type_id BIGINT NOT NULL,
  code VARCHAR(80) UNIQUE NOT NULL,
  deck VARCHAR(20),
  area DOUBLE PRECISION,
  max_guests INT NOT NULL,
  status SMALLINT DEFAULT 1,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS cabin_prices (
  id BIGSERIAL PRIMARY KEY,
  cabin_sku_id BIGINT NOT NULL REFERENCES cabin_skus(id),
  date TIMESTAMP NOT NULL,
  occupancy INT NOT NULL,
  price_cents BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS cabin_inventories (
  id BIGSERIAL PRIMARY KEY,
  cabin_sku_id BIGINT UNIQUE NOT NULL REFERENCES cabin_skus(id),
  total INT NOT NULL,
  locked INT NOT NULL DEFAULT 0,
  sold INT NOT NULL DEFAULT 0,
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS inventory_logs (
  id BIGSERIAL PRIMARY KEY,
  cabin_sku_id BIGINT NOT NULL REFERENCES cabin_skus(id),
  change INT NOT NULL,
  reason VARCHAR(200) NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

Create `backend/migrations/000002_route_voyage_cabin.down.sql`:

```sql
DROP TABLE IF EXISTS inventory_logs;
DROP TABLE IF EXISTS cabin_inventories;
DROP TABLE IF EXISTS cabin_prices;
DROP TABLE IF EXISTS cabin_skus;
DROP TABLE IF EXISTS voyages;
DROP TABLE IF EXISTS routes;
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./migrations -run TestSprint2MigrationFilesExist -v`
Expected: PASS

**Step 5: Refactor (index coverage)**

Update `backend/migrations/000002_route_voyage_cabin.up.sql` to add indexes:

```sql
CREATE INDEX IF NOT EXISTS idx_voyages_route_id ON voyages(route_id);
CREATE INDEX IF NOT EXISTS idx_cabin_prices_sku_date ON cabin_prices(cabin_sku_id, date);
```

Run: `cd backend && go test ./migrations -run TestSprint2MigrationFilesExist -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/migrations/000002_route_voyage_cabin.up.sql backend/migrations/000002_route_voyage_cabin.down.sql backend/migrations/migrations_sprint2_test.go
git commit -m "feat: add route voyage cabin schema"
```

---

### Task 3: Route/Voyage/Cabin Repositories

**Files:**
- Create: `backend/internal/repository/route_repo.go`
- Create: `backend/internal/repository/voyage_repo.go`
- Create: `backend/internal/repository/cabin_repo.go`
- Test: `backend/internal/repository/route_repo_test.go`

**Step 1: Write the failing test**

Create `backend/internal/repository/route_repo_test.go`:

```go
package repository

import (
    "testing"

    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func TestRouteRepoCreateAndList(t *testing.T) {
    db, _ := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    _ = db.AutoMigrate(&domain.Route{})
    repo := NewRouteRepository(db)
    if err := repo.Create(&domain.Route{Code: "R1", Name: "Route 1"}); err != nil {
        t.Fatal(err)
    }
    list, err := repo.List()
    if err != nil || len(list) != 1 {
        t.Fatal("expected 1 route")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/repository -run TestRouteRepoCreateAndList -v`
Expected: FAIL with "undefined: NewRouteRepository"

**Step 3: Write minimal implementation**

Create `backend/internal/repository/route_repo.go`:

```go
package repository

import (
    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/gorm"
)

type RouteRepository struct { db *gorm.DB }

func NewRouteRepository(db *gorm.DB) *RouteRepository { return &RouteRepository{db: db} }

func (r *RouteRepository) Create(v *domain.Route) error { return r.db.Create(v).Error }
func (r *RouteRepository) List() ([]domain.Route, error) {
    var out []domain.Route
    return out, r.db.Order("id desc").Find(&out).Error
}
```

Create `backend/internal/repository/voyage_repo.go`:

```go
package repository

import (
    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/gorm"
)

type VoyageRepository struct { db *gorm.DB }

func NewVoyageRepository(db *gorm.DB) *VoyageRepository { return &VoyageRepository{db: db} }

func (r *VoyageRepository) Create(v *domain.Voyage) error { return r.db.Create(v).Error }
func (r *VoyageRepository) ListByRoute(routeID int64) ([]domain.Voyage, error) {
    var out []domain.Voyage
    return out, r.db.Where("route_id = ?", routeID).Order("depart_date asc").Find(&out).Error
}
```

Create `backend/internal/repository/cabin_repo.go`:

```go
package repository

import (
    "github.com/cruisebooking/backend/internal/domain"
    "gorm.io/gorm"
)

type CabinRepository struct { db *gorm.DB }

func NewCabinRepository(db *gorm.DB) *CabinRepository { return &CabinRepository{db: db} }

func (r *CabinRepository) CreateSKU(v *domain.CabinSKU) error { return r.db.Create(v).Error }
func (r *CabinRepository) ListSKUByVoyage(voyageID int64) ([]domain.CabinSKU, error) {
    var out []domain.CabinSKU
    return out, r.db.Where("voyage_id = ?", voyageID).Order("id desc").Find(&out).Error
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/repository -run TestRouteRepoCreateAndList -v`
Expected: PASS

**Step 5: Refactor (shared base)**

Update `backend/internal/repository/route_repo.go` to add a small helper:

```go
type RouteRepository struct { db *gorm.DB }

func (r *RouteRepository) withDB() *gorm.DB { return r.db }
```

Run: `cd backend && go test ./internal/repository -run TestRouteRepoCreateAndList -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/repository/route_repo.go backend/internal/repository/voyage_repo.go backend/internal/repository/cabin_repo.go backend/internal/repository/route_repo_test.go
git commit -m "feat: add repositories for routes voyages and cabins"
```

---

### Task 4: Pricing Matrix Service

**Files:**
- Create: `backend/internal/service/pricing_service.go`
- Create: `backend/internal/service/pricing_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/pricing_service_test.go`:

```go
package service

import (
    "testing"
    "time"

    "github.com/cruisebooking/backend/internal/domain"
)

type fakePriceRepo struct { prices []domain.CabinPrice }
func (f fakePriceRepo) ListBySKU(skuID int64) ([]domain.CabinPrice, error) { return f.prices, nil }

func TestPricingServiceFindPrice(t *testing.T) {
    d := time.Date(2026, 5, 1, 0, 0, 0, 0, time.UTC)
    svc := NewPricingService(fakePriceRepo{prices: []domain.CabinPrice{{CabinSKUID: 1, Date: d, Occupancy: 2, PriceCents: 19900}}})
    p, ok := svc.FindPrice(1, d, 2)
    if !ok || p != 19900 {
        t.Fatal("expected price 19900")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestPricingServiceFindPrice -v`
Expected: FAIL with "undefined: NewPricingService"

**Step 3: Write minimal implementation**

Create `backend/internal/service/pricing_service.go`:

```go
package service

import (
    "time"

    "github.com/cruisebooking/backend/internal/domain"
)

type PriceRepo interface {
    ListBySKU(skuID int64) ([]domain.CabinPrice, error)
}

type PricingService struct { repo PriceRepo }

func NewPricingService(repo PriceRepo) *PricingService { return &PricingService{repo: repo} }

func (s *PricingService) FindPrice(skuID int64, date time.Time, occupancy int) (int64, bool) {
    list, _ := s.repo.ListBySKU(skuID)
    for _, v := range list {
        if v.Date.Equal(date) && v.Occupancy == occupancy {
            return v.PriceCents, true
        }
    }
    return 0, false
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestPricingServiceFindPrice -v`
Expected: PASS

**Step 5: Refactor (date-only matching)**

Update `backend/internal/service/pricing_service.go`:

```go
func sameDay(a, b time.Time) bool {
    y1, m1, d1 := a.Date()
    y2, m2, d2 := b.Date()
    return y1 == y2 && m1 == m2 && d1 == d2
}

func (s *PricingService) FindPrice(skuID int64, date time.Time, occupancy int) (int64, bool) {
    list, _ := s.repo.ListBySKU(skuID)
    for _, v := range list {
        if sameDay(v.Date, date) && v.Occupancy == occupancy {
            return v.PriceCents, true
        }
    }
    return 0, false
}
```

Run: `cd backend && go test ./internal/service -run TestPricingServiceFindPrice -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/service/pricing_service.go backend/internal/service/pricing_service_test.go
git commit -m "feat: add pricing matrix service"
```

---

### Task 5: Inventory Service + Log

**Files:**
- Create: `backend/internal/service/inventory_service.go`
- Create: `backend/internal/service/inventory_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/inventory_service_test.go`:

```go
package service

import (
    "testing"

    "github.com/cruisebooking/backend/internal/domain"
)

type fakeInventoryRepo struct { inv domain.CabinInventory }
func (f *fakeInventoryRepo) GetBySKU(id int64) (domain.CabinInventory, error) { return f.inv, nil }
func (f *fakeInventoryRepo) Update(inv *domain.CabinInventory) error { f.inv = *inv; return nil }

func TestInventoryServiceAdjust(t *testing.T) {
    repo := &fakeInventoryRepo{inv: domain.CabinInventory{CabinSKUID: 1, Total: 10, Locked: 0, Sold: 0}}
    svc := NewInventoryService(repo)
    if err := svc.Adjust(1, -2); err != nil {
        t.Fatal(err)
    }
    if repo.inv.Total != 8 {
        t.Fatal("expected total 8")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestInventoryServiceAdjust -v`
Expected: FAIL with "undefined: NewInventoryService"

**Step 3: Write minimal implementation**

Create `backend/internal/service/inventory_service.go`:

```go
package service

import "github.com/cruisebooking/backend/internal/domain"

type InventoryRepo interface {
    GetBySKU(id int64) (domain.CabinInventory, error)
    Update(inv *domain.CabinInventory) error
}

type InventoryService struct { repo InventoryRepo }

func NewInventoryService(repo InventoryRepo) *InventoryService { return &InventoryService{repo: repo} }

func (s *InventoryService) Adjust(skuID int64, delta int) error {
    inv, err := s.repo.GetBySKU(skuID)
    if err != nil { return err }
    inv.Total += delta
    return s.repo.Update(&inv)
}

func (s *InventoryService) Available(skuID int64) (int, error) {
    inv, err := s.repo.GetBySKU(skuID)
    if err != nil { return 0, err }
    return inv.Total - inv.Locked - inv.Sold, nil
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestInventoryServiceAdjust -v`
Expected: PASS

**Step 5: Refactor (guard negative)**

Update `backend/internal/service/inventory_service.go`:

```go
func (s *InventoryService) Adjust(skuID int64, delta int) error {
    inv, err := s.repo.GetBySKU(skuID)
    if err != nil { return err }
    if inv.Total+delta < 0 { return nil }
    inv.Total += delta
    return s.repo.Update(&inv)
}
```

Run: `cd backend && go test ./internal/service -run TestInventoryServiceAdjust -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/service/inventory_service.go backend/internal/service/inventory_service_test.go
git commit -m "feat: add cabin inventory service"
```

---

## Part B: Backend APIs + Search (Tasks 6-7)

### Task 6: Admin CRUD + Public Search Handlers

**Files:**
- Create: `backend/internal/handler/route_handler.go`
- Create: `backend/internal/handler/voyage_handler.go`
- Create: `backend/internal/handler/cabin_handler.go`
- Modify: `backend/internal/router/router.go`
- Test: `backend/internal/handler/route_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/route_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestRouteListHandler(t *testing.T) {
    r := gin.New()
    h := NewRouteHandler(nil)
    r.GET("/admin/routes", h.List)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("GET", "/admin/routes", nil))
    if w.Code != http.StatusOK {
        t.Fatalf("expected 200, got %d", w.Code)
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestRouteListHandler -v`
Expected: FAIL with "undefined: NewRouteHandler"

**Step 3: Write minimal implementation**

Create `backend/internal/handler/route_handler.go`:

```go
package handler

import (
    "net/http"

    "github.com/cruisebooking/backend/internal/pkg/response"
    "github.com/gin-gonic/gin"
)

type RouteHandler struct {}

func NewRouteHandler(_ interface{}) *RouteHandler { return &RouteHandler{} }

func (h *RouteHandler) List(c *gin.Context) {
    response.Success(c, []interface{}{})
}
```

Create `backend/internal/handler/voyage_handler.go` and `backend/internal/handler/cabin_handler.go` with placeholder list endpoints.

Modify `backend/internal/router/router.go`:

```go
r := gin.New()
admin := r.Group("/admin")
admin.GET("/routes", routeHandler.List)
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestRouteListHandler -v`
Expected: PASS

**Step 5: Refactor (wire real services)**

Update `backend/internal/handler/route_handler.go`:

```go
type RouteService interface { List() ([]interface{}, error) }

type RouteHandler struct { svc RouteService }

func NewRouteHandler(svc RouteService) *RouteHandler { return &RouteHandler{svc: svc} }

func (h *RouteHandler) List(c *gin.Context) {
    list, _ := h.svc.List()
    response.Success(c, list)
}
```

Run: `cd backend && go test ./internal/handler -run TestRouteListHandler -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/handler/route_handler.go backend/internal/handler/voyage_handler.go backend/internal/handler/cabin_handler.go backend/internal/handler/route_handler_test.go backend/internal/router/router.go
git commit -m "feat: add route voyage cabin handlers"
```

---

### Task 7: Meilisearch Indexing for Cabin Search

**Files:**
- Create: `backend/internal/service/search_service.go`
- Create: `backend/internal/service/search_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/search_service_test.go`:

```go
package service

import "testing"

type fakeIndexer struct{ called bool }
func (f *fakeIndexer) IndexCabin(_ interface{}) error { f.called = true; return nil }

func TestSearchServiceIndexCabin(t *testing.T) {
    idx := &fakeIndexer{}
    svc := NewSearchService(idx)
    _ = svc.IndexCabin(map[string]interface{}{ "id": 1 })
    if !idx.called {
        t.Fatal("expected index call")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestSearchServiceIndexCabin -v`
Expected: FAIL with "undefined: NewSearchService"

**Step 3: Write minimal implementation**

Create `backend/internal/service/search_service.go`:

```go
package service

type CabinIndexer interface {
    IndexCabin(doc interface{}) error
}

type SearchService struct { idx CabinIndexer }

func NewSearchService(idx CabinIndexer) *SearchService { return &SearchService{idx: idx} }

func (s *SearchService) IndexCabin(doc interface{}) error {
    return s.idx.IndexCabin(doc)
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestSearchServiceIndexCabin -v`
Expected: PASS

**Step 5: Refactor (meili adapter)**

Create `backend/internal/pkg/search/meili.go`:

```go
package search

import "github.com/meilisearch/meilisearch-go"

type MeiliIndexer struct { client *meilisearch.Client }

func NewMeiliIndexer(url, key string) *MeiliIndexer {
    return &MeiliIndexer{client: meilisearch.NewClient(meilisearch.ClientConfig{Host: url, APIKey: key})}
}

func (m *MeiliIndexer) IndexCabin(doc interface{}) error {
    _, err := m.client.Index("cabins").AddDocuments([]interface{}{doc})
    return err
}
```

Run: `cd backend && go test ./internal/service -run TestSearchServiceIndexCabin -v`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/internal/service/search_service.go backend/internal/service/search_service_test.go backend/internal/pkg/search/meili.go
git commit -m "feat: add meilisearch indexing service"
```

---

## Part C: Admin (Tasks 8-9)

> Follow @vue-best-practices and @vue-testing-best-practices. Use `<script setup lang="ts">`.

### Task 8: Admin Routes + Voyages CRUD Pages

**Files:**
- Create: `frontend/admin/pages/routes/index.vue`
- Create: `frontend/admin/pages/routes/new.vue`
- Create: `frontend/admin/pages/voyages/index.vue`
- Create: `frontend/admin/pages/voyages/new.vue`
- Test: `frontend/admin/tests/unit/routes.list.spec.ts`

**Step 1: Write the failing test**

Create `frontend/admin/tests/unit/routes.list.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import RoutesPage from '../../pages/routes/index.vue'

describe('Admin Routes List', () => {
  it('renders title', () => {
    const wrapper = mount(RoutesPage)
    expect(wrapper.text()).toContain('Routes')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/admin && pnpm vitest run tests/unit/routes.list.spec.ts`
Expected: FAIL with "Cannot find module"

**Step 3: Write minimal implementation**

Create `frontend/admin/pages/routes/index.vue`:

```vue
<script setup lang="ts">
const items = [{ id: 1, code: 'R1', name: 'Route 1' }]
</script>

<template>
  <div class="page">
    <h1>Routes</h1>
    <table>
      <tbody>
        <tr v-for="r in items" :key="r.id">
          <td>{{ r.code }}</td>
          <td>{{ r.name }}</td>
        </tr>
      </tbody>
    </table>
  </div>
</template>
```

Create `frontend/admin/pages/routes/new.vue`:

```vue
<script setup lang="ts">
const form = ref({ code: '', name: '' })
</script>

<template>
  <div class="page">
    <h1>New Route</h1>
    <input v-model="form.code" placeholder="Code" />
    <input v-model="form.name" placeholder="Name" />
  </div>
</template>
```

Create `frontend/admin/pages/voyages/index.vue` and `frontend/admin/pages/voyages/new.vue` with similar scaffold.

**Step 4: Run test to verify it passes**

Run: `cd frontend/admin && pnpm vitest run tests/unit/routes.list.spec.ts`
Expected: PASS

**Step 5: Refactor (extract table)**

Create `frontend/admin/components/RouteTable.vue` and update `frontend/admin/pages/routes/index.vue`:

```vue
<script setup lang="ts">
defineProps<{ items: { id: number; code: string; name: string }[] }>()
</script>

<template>
  <table>
    <tbody>
      <tr v-for="r in items" :key="r.id">
        <td>{{ r.code }}</td>
        <td>{{ r.name }}</td>
      </tr>
    </tbody>
  </table>
</template>
```

Run: `cd frontend/admin && pnpm vitest run tests/unit/routes.list.spec.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add frontend/admin/pages/routes/index.vue frontend/admin/pages/routes/new.vue frontend/admin/pages/voyages/index.vue frontend/admin/pages/voyages/new.vue frontend/admin/components/RouteTable.vue frontend/admin/tests/unit/routes.list.spec.ts
git commit -m "feat: add admin routes and voyages pages"
```

---

### Task 9: Admin Cabin SKU + Pricing + Inventory Pages

**Files:**
- Create: `frontend/admin/pages/cabins/index.vue`
- Create: `frontend/admin/pages/cabins/pricing.vue`
- Create: `frontend/admin/pages/cabins/inventory.vue`
- Test: `frontend/admin/tests/unit/cabins.pricing.spec.ts`

**Step 1: Write the failing test**

Create `frontend/admin/tests/unit/cabins.pricing.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import PricingPage from '../../pages/cabins/pricing.vue'

describe('Cabin Pricing Page', () => {
  it('shows pricing title', () => {
    const wrapper = mount(PricingPage)
    expect(wrapper.text()).toContain('Pricing Matrix')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/admin && pnpm vitest run tests/unit/cabins.pricing.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/admin/pages/cabins/pricing.vue`:

```vue
<script setup lang="ts">
const rows = [{ date: '2026-05-01', occupancy: 2, price: 19900 }]
</script>

<template>
  <div class="page">
    <h1>Pricing Matrix</h1>
    <div v-for="r in rows" :key="r.date">
      {{ r.date }} / {{ r.occupancy }} / {{ r.price }}
    </div>
  </div>
</template>
```

Create `frontend/admin/pages/cabins/index.vue` and `frontend/admin/pages/cabins/inventory.vue` with minimal scaffold.

**Step 4: Run test to verify it passes**

Run: `cd frontend/admin && pnpm vitest run tests/unit/cabins.pricing.spec.ts`
Expected: PASS

**Step 5: Refactor (extract row component)**

Create `frontend/admin/components/PricingRow.vue` and update pricing page to use it.

**Step 6: Commit**

```bash
git add frontend/admin/pages/cabins/index.vue frontend/admin/pages/cabins/pricing.vue frontend/admin/pages/cabins/inventory.vue frontend/admin/components/PricingRow.vue frontend/admin/tests/unit/cabins.pricing.spec.ts
git commit -m "feat: add admin cabin pricing and inventory pages"
```

---

## Part D: Web Frontend (Task 10)

> Follow @vue-best-practices and @vue-testing-best-practices. Use `<script setup lang="ts">`.

### Task 10: Web Search + Cabin Detail

**Files:**
- Create: `frontend/web/pages/search/index.vue`
- Create: `frontend/web/pages/cabins/[id].vue`
- Test: `frontend/web/tests/unit/search.page.spec.ts`

**Step 1: Write the failing test**

Create `frontend/web/tests/unit/search.page.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import SearchPage from '../../pages/search/index.vue'

describe('Search Page', () => {
  it('renders filters', () => {
    const wrapper = mount(SearchPage)
    expect(wrapper.text()).toContain('Filter')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/web && pnpm vitest run tests/unit/search.page.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/web/pages/search/index.vue`:

```vue
<script setup lang="ts">
const results = [{ id: 1, name: 'Balcony Cabin', price: 19900 }]
</script>

<template>
  <div class="page">
    <h1>Search</h1>
    <div>Filter</div>
    <div v-for="r in results" :key="r.id">{{ r.name }} - {{ r.price }}</div>
  </div>
</template>
```

Create `frontend/web/pages/cabins/[id].vue` with a simple price calendar list.

**Step 4: Run test to verify it passes**

Run: `cd frontend/web && pnpm vitest run tests/unit/search.page.spec.ts`
Expected: PASS

**Step 5: Refactor (extract card component)**

Create `frontend/web/components/CabinCard.vue` and update search page to use it.

**Step 6: Commit**

```bash
git add frontend/web/pages/search/index.vue frontend/web/pages/cabins/[id].vue frontend/web/components/CabinCard.vue frontend/web/tests/unit/search.page.spec.ts
git commit -m "feat: add web search and cabin detail pages"
```

---

## Part E: Miniapp (Task 11)

### Task 11: Miniapp Cabin List + Detail

**Files:**
- Create: `frontend/miniapp/pages/cabin/list.vue`
- Create: `frontend/miniapp/pages/cabin/detail.vue`
- Test: `frontend/miniapp/tests/cabin-list.spec.ts`

**Step 1: Write the failing test**

Create `frontend/miniapp/tests/cabin-list.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/vue'
import List from '../pages/cabin/list.vue'

describe('Cabin List', () => {
  it('shows title', () => {
    const { getByText } = render(List)
    expect(getByText('Cabins')).toBeTruthy()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/miniapp && pnpm vitest run tests/cabin-list.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/miniapp/pages/cabin/list.vue`:

```vue
<template>
  <view class="page">
    <text>Cabins</text>
  </view>
</template>
```

Create `frontend/miniapp/pages/cabin/detail.vue` with a simple detail view.

**Step 4: Run test to verify it passes**

Run: `cd frontend/miniapp && pnpm vitest run tests/cabin-list.spec.ts`
Expected: PASS

**Step 5: Refactor (shared card)**

Create `frontend/miniapp/components/CabinCard.vue` and use it in list.

**Step 6: Commit**

```bash
git add frontend/miniapp/pages/cabin/list.vue frontend/miniapp/pages/cabin/detail.vue frontend/miniapp/components/CabinCard.vue frontend/miniapp/tests/cabin-list.spec.ts
git commit -m "feat: add miniapp cabin list and detail"
```

---

## Part F: CI (Task 12)

### Task 12: CI Coverage for Sprint 2

**Files:**
- Modify: `.github/workflows/ci.yml`

**Step 1: Write the failing test**

Add a CI check step placeholder in `.github/workflows/ci.yml` that expects `frontend/admin` tests to run with new files (initially missing).

**Step 2: Run test to verify it fails**

Run: `act -j test-admin` (or GitHub Actions run) and expect missing file failure.

**Step 3: Write minimal implementation**

Update `.github/workflows/ci.yml`:

```yaml
  test-admin:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with: { version: 9 }
      - run: cd frontend/admin && pnpm install && pnpm vitest run
```

**Step 4: Run test to verify it passes**

Run: `act -j test-admin`
Expected: PASS

**Step 5: Refactor (cache pnpm)**

Add cache steps for pnpm store.

**Step 6: Commit**

```bash
git add .github/workflows/ci.yml
git commit -m "ci: add admin tests for sprint2"
```

---

## Final Verification

Run:

```bash
cd backend && go test ./... -coverprofile=coverage.out -covermode=atomic
cd frontend/admin && pnpm vitest run
cd frontend/web && pnpm vitest run
cd frontend/miniapp && pnpm vitest run
```

Expected: All tests pass and coverage remains at 100%.
