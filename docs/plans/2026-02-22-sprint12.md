# Sprint 12: 智能运营（下）Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 实现收益管理看板、客户生命周期管理与自动化营销规则。

**Architecture:** 后端增加收益指标、客户画像与营销规则模型，提供看板与触发API；后台配置与分析页面；前端展示个性化营销卡片。TDD驱动。

**Tech Stack:** Go 1.26, Gin, GORM, PostgreSQL, Nuxt 4 (admin/web), Vue 3, Pinia, Vitest, Playwright, uni-app.

---

## Part A: Backend (Tasks 1-4)

### Task 1: 收益与CRM领域模型

**Files:**
- Create: `backend/internal/domain/revenue_metric.go`
- Create: `backend/internal/domain/customer_profile.go`
- Create: `backend/internal/domain/marketing_rule.go`
- Test: `backend/internal/domain/ops2_domain_test.go`

**Step 1: Write the failing test**

Create `backend/internal/domain/ops2_domain_test.go`:

```go
package domain

import "testing"

func TestRevenueMetricModel(t *testing.T) {
    m := RevenueMetric{Metric: "RevPAR", Value: 120}
    if m.Metric == "" || m.Value == 0 {
        t.Fatal("expected revenue metric")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/domain -run TestRevenueMetricModel -v`
Expected: FAIL with "undefined: RevenueMetric"

**Step 3: Write minimal implementation**

Create `backend/internal/domain/revenue_metric.go`:

```go
package domain

import "time"

type RevenueMetric struct {
    ID int64 `gorm:"primaryKey"`
    Metric string `gorm:"size:50"`
    Value float64
    RecordedAt time.Time
}
```

Create `backend/internal/domain/customer_profile.go`:

```go
package domain

import "time"

type CustomerProfile struct {
    ID int64 `gorm:"primaryKey"`
    UserID int64
    Segment string `gorm:"size:50"`
    Tags string `gorm:"type:text"`
    LastOrderAt *time.Time
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

Create `backend/internal/domain/marketing_rule.go`:

```go
package domain

import "time"

type MarketingRule struct {
    ID int64 `gorm:"primaryKey"`
    Name string `gorm:"size:100"`
    Trigger string `gorm:"size:100"`
    Action string `gorm:"size:100"`
    Status int16 `gorm:"default:1"`
    CreatedAt time.Time
    UpdatedAt time.Time
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/domain -run TestRevenueMetricModel -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/domain/revenue_metric.go backend/internal/domain/customer_profile.go backend/internal/domain/marketing_rule.go backend/internal/domain/ops2_domain_test.go
git commit -m "feat: add revenue, crm, and marketing rule models"
```

---

### Task 2: CRM 服务

**Files:**
- Create: `backend/internal/service/crm_service.go`
- Test: `backend/internal/service/crm_service_test.go`

**Step 1: Write the failing test**

Create `backend/internal/service/crm_service_test.go`:

```go
package service

import "testing"

func TestSegment(t *testing.T) {
    svc := NewCRMService()
    segment := svc.Segment(5)
    if segment == "" {
        t.Fatal("expected segment")
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/service -run TestSegment -v`
Expected: FAIL with "undefined: NewCRMService"

**Step 3: Write minimal implementation**

Create `backend/internal/service/crm_service.go`:

```go
package service

type CRMService struct{}

func NewCRMService() *CRMService { return &CRMService{} }

func (s *CRMService) Segment(orderCount int) string {
    if orderCount >= 5 { return "vip" }
    return "standard"
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/service -run TestSegment -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/service/crm_service.go backend/internal/service/crm_service_test.go
git commit -m "feat: add crm segmentation service"
```

---

### Task 3: Marketing Trigger API

**Files:**
- Create: `backend/internal/handler/marketing_handler.go`
- Test: `backend/internal/handler/marketing_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/marketing_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestMarketingTriggerAPI(t *testing.T) {
    r := gin.New()
    h := NewMarketingHandler()
    r.POST("/marketing/trigger", h.Trigger)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("POST", "/marketing/trigger", nil))
    if w.Code != http.StatusOK { t.Fatalf("expected 200, got %d", w.Code) }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestMarketingTriggerAPI -v`
Expected: FAIL with "undefined: NewMarketingHandler"

**Step 3: Write minimal implementation**

Create `backend/internal/handler/marketing_handler.go`:

```go
package handler

import "github.com/gin-gonic/gin"

type MarketingHandler struct{}

func NewMarketingHandler() *MarketingHandler { return &MarketingHandler{} }

func (h *MarketingHandler) Trigger(c *gin.Context) { c.JSON(200, gin.H{"ok": true}) }
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestMarketingTriggerAPI -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/handler/marketing_handler.go backend/internal/handler/marketing_handler_test.go
git commit -m "feat: add marketing trigger handler"
```

---

### Task 4: 收益看板 API

**Files:**
- Create: `backend/internal/handler/revenue_handler.go`
- Test: `backend/internal/handler/revenue_handler_test.go`

**Step 1: Write the failing test**

Create `backend/internal/handler/revenue_handler_test.go`:

```go
package handler

import (
    "net/http"
    "net/http/httptest"
    "testing"

    "github.com/gin-gonic/gin"
)

func TestRevenueDashboardAPI(t *testing.T) {
    r := gin.New()
    h := NewRevenueHandler()
    r.GET("/revenue/dashboard", h.Dashboard)
    w := httptest.NewRecorder()
    r.ServeHTTP(w, httptest.NewRequest("GET", "/revenue/dashboard", nil))
    if w.Code != http.StatusOK { t.Fatalf("expected 200, got %d", w.Code) }
}
```

**Step 2: Run test to verify it fails**

Run: `cd backend && go test ./internal/handler -run TestRevenueDashboardAPI -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `backend/internal/handler/revenue_handler.go`:

```go
package handler

import "github.com/gin-gonic/gin"

type RevenueHandler struct{}

func NewRevenueHandler() *RevenueHandler { return &RevenueHandler{} }

func (h *RevenueHandler) Dashboard(c *gin.Context) {
    c.JSON(200, gin.H{"metrics": []string{}})
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && go test ./internal/handler -run TestRevenueDashboardAPI -v`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/internal/handler/revenue_handler.go backend/internal/handler/revenue_handler_test.go
git commit -m "feat: add revenue dashboard handler"
```

---

## Part B: Admin (Task 5)

> Follow @vue-best-practices and @vue-testing-best-practices.

### Task 5: 收益管理看板页面

**Files:**
- Create: `frontend/admin/pages/ops/revenue.vue`
- Test: `frontend/admin/tests/unit/ops/revenue.spec.ts`

**Step 1: Write the failing test**

Create `frontend/admin/tests/unit/ops/revenue.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import RevenuePage from '@/pages/ops/revenue.vue'

describe('RevenuePage', () => {
  it('renders dashboard', () => {
    const wrapper = mount(RevenuePage)
    expect(wrapper.text()).toContain('Revenue Dashboard')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/admin && pnpm vitest run tests/unit/ops/revenue.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/admin/pages/ops/revenue.vue`:

```vue
<script setup lang="ts">
const metrics = ref([{ label: 'RevPAR', value: 120 }])
</script>

<template>
  <section>
    <h1>Revenue Dashboard</h1>
    <ul>
      <li v-for="m in metrics" :key="m.label">{{ m.label }}: {{ m.value }}</li>
    </ul>
  </section>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/admin && pnpm vitest run tests/unit/ops/revenue.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/admin/pages/ops/revenue.vue frontend/admin/tests/unit/ops/revenue.spec.ts
git commit -m "feat: add revenue dashboard admin page"
```

---

## Part C: Web (Task 6)

### Task 6: 个性化营销卡片

**Files:**
- Create: `frontend/web/components/MarketingCard.vue`
- Test: `frontend/web/tests/unit/marketing-card.spec.ts`

**Step 1: Write the failing test**

Create `frontend/web/tests/unit/marketing-card.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import MarketingCard from '@/components/MarketingCard.vue'

describe('MarketingCard', () => {
  it('renders title', () => {
    const wrapper = mount(MarketingCard, { props: { title: 'Special' } })
    expect(wrapper.text()).toContain('Special')
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/web && pnpm vitest run tests/unit/marketing-card.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/web/components/MarketingCard.vue`:

```vue
<script setup lang="ts">
defineProps<{ title: string }>()
</script>

<template>
  <article>{{ title }}</article>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/web && pnpm vitest run tests/unit/marketing-card.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/web/components/MarketingCard.vue frontend/web/tests/unit/marketing-card.spec.ts
git commit -m "feat: add marketing card component"
```

---

## Part D: Miniapp (Task 7)

### Task 7: 小程序营销消息中心

**Files:**
- Create: `frontend/miniapp/pages/marketing/marketing.vue`
- Test: `frontend/miniapp/tests/marketing.spec.ts`

**Step 1: Write the failing test**

Create `frontend/miniapp/tests/marketing.spec.ts`:

```ts
import { describe, it, expect } from 'vitest'
import MarketingPage from '@/pages/marketing/marketing.vue'

describe('MarketingPage', () => {
  it('exists', () => {
    expect(MarketingPage).toBeTruthy()
  })
})
```

**Step 2: Run test to verify it fails**

Run: `cd frontend/miniapp && pnpm vitest run tests/marketing.spec.ts`
Expected: FAIL

**Step 3: Write minimal implementation**

Create `frontend/miniapp/pages/marketing/marketing.vue`:

```vue
<script setup lang="ts">
const items = ref<string[]>([])
</script>

<template>
  <view>
    <text>Marketing</text>
    <view v-for="m in items" :key="m">{{ m }}</view>
  </view>
</template>
```

**Step 4: Run test to verify it passes**

Run: `cd frontend/miniapp && pnpm vitest run tests/marketing.spec.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add frontend/miniapp/pages/marketing/marketing.vue frontend/miniapp/tests/marketing.spec.ts
git commit -m "feat: add miniapp marketing page"
```

---

## Part E: CI (Task 8)

### Task 8: CRM/Marketing Coverage Gate

**Files:**
- Modify: `.github/workflows/backend.yml`
- Modify: `.github/workflows/admin.yml`

**Step 1: Write the failing test**

Create `scripts/verify_crm_ci_test.go`:

```go
package scripts

import (
    "os"
    "testing"
)

func TestCRMWorkflowsExist(t *testing.T) {
    files := []string{".github/workflows/backend.yml", ".github/workflows/admin.yml"}
    for _, f := range files {
        if _, err := os.Stat(f); err != nil { t.Fatalf("expected %s", f) }
    }
}
```

**Step 2: Run test to verify it fails**

Run: `go test ./scripts -run TestCRMWorkflowsExist -v`
Expected: FAIL

**Step 3: Write minimal implementation**

Ensure workflows run coverage for new CRM modules.

**Step 4: Run test to verify it passes**

Run: `go test ./scripts -run TestCRMWorkflowsExist -v`
Expected: PASS

**Step 5: Commit**

```bash
git add .github/workflows scripts/verify_crm_ci_test.go
git commit -m "chore: enforce crm coverage in CI"
```

---

## Final Verification

Run:

```bash
cd backend && go test ./... -coverprofile=coverage.out -covermode=atomic -v
cd frontend/admin && pnpm vitest run --coverage && pnpm playwright test
cd frontend/web && pnpm vitest run --coverage && pnpm playwright test
cd frontend/miniapp && pnpm vitest run --coverage
```

Expected: All tests pass and coverage is 100%.
